{"mappings":"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","sources":["<anon>","js/chess.js"],"sourcesContent":["/*\r\n * Copyright (c) 2020, Jeff Hlywa (jhlywa@gmail.com)\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n *----------------------------------------------------------------------------*/ var Chess = function(fen) {\n    var BLACK = \"b\";\n    var WHITE = \"w\";\n    var EMPTY = -1;\n    var PAWN = \"p\";\n    var KNIGHT = \"n\";\n    var BISHOP = \"b\";\n    var ROOK = \"r\";\n    var QUEEN = \"q\";\n    var KING = \"k\";\n    var SYMBOLS = \"pnbrqkPNBRQK\";\n    var DEFAULT_POSITION = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\";\n    var POSSIBLE_RESULTS = [\n        \"1-0\",\n        \"0-1\",\n        \"1/2-1/2\",\n        \"*\"\n    ];\n    var PAWN_OFFSETS = {\n        b: [\n            16,\n            32,\n            17,\n            15\n        ],\n        w: [\n            -16,\n            -32,\n            -17,\n            -15\n        ]\n    };\n    var PIECE_OFFSETS = {\n        n: [\n            -18,\n            -33,\n            -31,\n            -14,\n            18,\n            33,\n            31,\n            14\n        ],\n        b: [\n            -17,\n            -15,\n            17,\n            15\n        ],\n        r: [\n            -16,\n            1,\n            16,\n            -1\n        ],\n        q: [\n            -17,\n            -16,\n            -15,\n            1,\n            17,\n            16,\n            15,\n            -1\n        ],\n        k: [\n            -17,\n            -16,\n            -15,\n            1,\n            17,\n            16,\n            15,\n            -1\n        ]\n    };\n    // prettier-ignore\n    var ATTACKS = [\n        20,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        24,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        0,\n        0,\n        24,\n        0,\n        0,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        0,\n        24,\n        0,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        24,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        24,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        20,\n        2,\n        24,\n        2,\n        20,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        2,\n        53,\n        56,\n        53,\n        2,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        24,\n        24,\n        24,\n        24,\n        24,\n        24,\n        56,\n        0,\n        56,\n        24,\n        24,\n        24,\n        24,\n        24,\n        24,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        2,\n        53,\n        56,\n        53,\n        2,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        20,\n        2,\n        24,\n        2,\n        20,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        24,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        24,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        0,\n        24,\n        0,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        0,\n        0,\n        24,\n        0,\n        0,\n        0,\n        0,\n        0,\n        20,\n        0,\n        0,\n        20,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        24,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        20\n    ];\n    // prettier-ignore\n    var RAYS = [\n        17,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        16,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        15,\n        0,\n        0,\n        17,\n        0,\n        0,\n        0,\n        0,\n        0,\n        16,\n        0,\n        0,\n        0,\n        0,\n        0,\n        15,\n        0,\n        0,\n        0,\n        0,\n        17,\n        0,\n        0,\n        0,\n        0,\n        16,\n        0,\n        0,\n        0,\n        0,\n        15,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        17,\n        0,\n        0,\n        0,\n        16,\n        0,\n        0,\n        0,\n        15,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        17,\n        0,\n        0,\n        16,\n        0,\n        0,\n        15,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        17,\n        0,\n        16,\n        0,\n        15,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        17,\n        16,\n        15,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        0,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        -15,\n        -16,\n        -17,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        -15,\n        0,\n        -16,\n        0,\n        -17,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        -15,\n        0,\n        0,\n        -16,\n        0,\n        0,\n        -17,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        -15,\n        0,\n        0,\n        0,\n        -16,\n        0,\n        0,\n        0,\n        -17,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        -15,\n        0,\n        0,\n        0,\n        0,\n        -16,\n        0,\n        0,\n        0,\n        0,\n        -17,\n        0,\n        0,\n        0,\n        0,\n        -15,\n        0,\n        0,\n        0,\n        0,\n        0,\n        -16,\n        0,\n        0,\n        0,\n        0,\n        0,\n        -17,\n        0,\n        0,\n        -15,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        -16,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        -17\n    ];\n    var SHIFTS = {\n        p: 0,\n        n: 1,\n        b: 2,\n        r: 3,\n        q: 4,\n        k: 5\n    };\n    var FLAGS = {\n        NORMAL: \"n\",\n        CAPTURE: \"c\",\n        BIG_PAWN: \"b\",\n        EP_CAPTURE: \"e\",\n        PROMOTION: \"p\",\n        KSIDE_CASTLE: \"k\",\n        QSIDE_CASTLE: \"q\"\n    };\n    var BITS = {\n        NORMAL: 1,\n        CAPTURE: 2,\n        BIG_PAWN: 4,\n        EP_CAPTURE: 8,\n        PROMOTION: 16,\n        KSIDE_CASTLE: 32,\n        QSIDE_CASTLE: 64\n    };\n    var RANK_1 = 7;\n    var RANK_2 = 6;\n    var RANK_3 = 5;\n    var RANK_4 = 4;\n    var RANK_5 = 3;\n    var RANK_6 = 2;\n    var RANK_7 = 1;\n    var RANK_8 = 0;\n    // prettier-ignore\n    var SQUARES = {\n        a8: 0,\n        b8: 1,\n        c8: 2,\n        d8: 3,\n        e8: 4,\n        f8: 5,\n        g8: 6,\n        h8: 7,\n        a7: 16,\n        b7: 17,\n        c7: 18,\n        d7: 19,\n        e7: 20,\n        f7: 21,\n        g7: 22,\n        h7: 23,\n        a6: 32,\n        b6: 33,\n        c6: 34,\n        d6: 35,\n        e6: 36,\n        f6: 37,\n        g6: 38,\n        h6: 39,\n        a5: 48,\n        b5: 49,\n        c5: 50,\n        d5: 51,\n        e5: 52,\n        f5: 53,\n        g5: 54,\n        h5: 55,\n        a4: 64,\n        b4: 65,\n        c4: 66,\n        d4: 67,\n        e4: 68,\n        f4: 69,\n        g4: 70,\n        h4: 71,\n        a3: 80,\n        b3: 81,\n        c3: 82,\n        d3: 83,\n        e3: 84,\n        f3: 85,\n        g3: 86,\n        h3: 87,\n        a2: 96,\n        b2: 97,\n        c2: 98,\n        d2: 99,\n        e2: 100,\n        f2: 101,\n        g2: 102,\n        h2: 103,\n        a1: 112,\n        b1: 113,\n        c1: 114,\n        d1: 115,\n        e1: 116,\n        f1: 117,\n        g1: 118,\n        h1: 119\n    };\n    var ROOKS = {\n        w: [\n            {\n                square: SQUARES.a1,\n                flag: BITS.QSIDE_CASTLE\n            },\n            {\n                square: SQUARES.h1,\n                flag: BITS.KSIDE_CASTLE\n            }\n        ],\n        b: [\n            {\n                square: SQUARES.a8,\n                flag: BITS.QSIDE_CASTLE\n            },\n            {\n                square: SQUARES.h8,\n                flag: BITS.KSIDE_CASTLE\n            }\n        ]\n    };\n    var board = new Array(128);\n    var kings = {\n        w: EMPTY,\n        b: EMPTY\n    };\n    var turn = WHITE;\n    var castling = {\n        w: 0,\n        b: 0\n    };\n    var ep_square = EMPTY;\n    var half_moves = 0;\n    var move_number = 1;\n    var history = [];\n    var header = {};\n    var comments = {};\n    /* if the user passes in a fen string, load it, else default to\r\n     * starting position\r\n     */ if (typeof fen === \"undefined\") load(DEFAULT_POSITION);\n    else load(fen);\n    function clear(keep_headers) {\n        if (typeof keep_headers === \"undefined\") keep_headers = false;\n        board = new Array(128);\n        kings = {\n            w: EMPTY,\n            b: EMPTY\n        };\n        turn = WHITE;\n        castling = {\n            w: 0,\n            b: 0\n        };\n        ep_square = EMPTY;\n        half_moves = 0;\n        move_number = 1;\n        history = [];\n        if (!keep_headers) header = {};\n        comments = {};\n        update_setup(generate_fen());\n    }\n    function prune_comments() {\n        var reversed_history = [];\n        var current_comments = {};\n        var copy_comment = function(fen) {\n            if (fen in comments) current_comments[fen] = comments[fen];\n        };\n        while(history.length > 0)reversed_history.push(undo_move());\n        copy_comment(generate_fen());\n        while(reversed_history.length > 0){\n            make_move(reversed_history.pop());\n            copy_comment(generate_fen());\n        }\n        comments = current_comments;\n    }\n    function reset() {\n        load(DEFAULT_POSITION);\n    }\n    function load(fen, keep_headers) {\n        if (typeof keep_headers === \"undefined\") keep_headers = false;\n        var tokens = fen.split(/\\s+/);\n        var position = tokens[0];\n        var square = 0;\n        if (!validate_fen(fen).valid) return false;\n        clear(keep_headers);\n        for(var i = 0; i < position.length; i++){\n            var piece = position.charAt(i);\n            if (piece === \"/\") square += 8;\n            else if (is_digit(piece)) square += parseInt(piece, 10);\n            else {\n                var color = piece < \"a\" ? WHITE : BLACK;\n                put({\n                    type: piece.toLowerCase(),\n                    color: color\n                }, algebraic(square));\n                square++;\n            }\n        }\n        turn = tokens[1];\n        if (tokens[2].indexOf(\"K\") > -1) castling.w |= BITS.KSIDE_CASTLE;\n        if (tokens[2].indexOf(\"Q\") > -1) castling.w |= BITS.QSIDE_CASTLE;\n        if (tokens[2].indexOf(\"k\") > -1) castling.b |= BITS.KSIDE_CASTLE;\n        if (tokens[2].indexOf(\"q\") > -1) castling.b |= BITS.QSIDE_CASTLE;\n        ep_square = tokens[3] === \"-\" ? EMPTY : SQUARES[tokens[3]];\n        half_moves = parseInt(tokens[4], 10);\n        move_number = parseInt(tokens[5], 10);\n        update_setup(generate_fen());\n        return true;\n    }\n    /* TODO: this function is pretty much crap - it validates structure but\r\n     * completely ignores content (e.g. doesn't verify that each side has a king)\r\n     * ... we should rewrite this, and ditch the silly error_number field while\r\n     * we're at it\r\n     */ function validate_fen(fen) {\n        var errors = {\n            0: \"No errors.\",\n            1: \"FEN string must contain six space-delimited fields.\",\n            2: \"6th field (move number) must be a positive integer.\",\n            3: \"5th field (half move counter) must be a non-negative integer.\",\n            4: \"4th field (en-passant square) is invalid.\",\n            5: \"3rd field (castling availability) is invalid.\",\n            6: \"2nd field (side to move) is invalid.\",\n            7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\n            8: \"1st field (piece positions) is invalid [consecutive numbers].\",\n            9: \"1st field (piece positions) is invalid [invalid piece].\",\n            10: \"1st field (piece positions) is invalid [row too large].\",\n            11: \"Illegal en-passant square\"\n        };\n        /* 1st criterion: 6 space-seperated fields? */ var tokens = fen.split(/\\s+/);\n        if (tokens.length !== 6) return {\n            valid: false,\n            error_number: 1,\n            error: errors[1]\n        };\n        /* 2nd criterion: move number field is a integer value > 0? */ if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) return {\n            valid: false,\n            error_number: 2,\n            error: errors[2]\n        };\n        /* 3rd criterion: half move counter is an integer >= 0? */ if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) return {\n            valid: false,\n            error_number: 3,\n            error: errors[3]\n        };\n        /* 4th criterion: 4th field is a valid e.p.-string? */ if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) return {\n            valid: false,\n            error_number: 4,\n            error: errors[4]\n        };\n        /* 5th criterion: 3th field is a valid castle-string? */ if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) return {\n            valid: false,\n            error_number: 5,\n            error: errors[5]\n        };\n        /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */ if (!/^(w|b)$/.test(tokens[1])) return {\n            valid: false,\n            error_number: 6,\n            error: errors[6]\n        };\n        /* 7th criterion: 1st field contains 8 rows? */ var rows = tokens[0].split(\"/\");\n        if (rows.length !== 8) return {\n            valid: false,\n            error_number: 7,\n            error: errors[7]\n        };\n        /* 8th criterion: every row is valid? */ for(var i = 0; i < rows.length; i++){\n            /* check for right sum of fields AND not two numbers in succession */ var sum_fields = 0;\n            var previous_was_number = false;\n            for(var k = 0; k < rows[i].length; k++)if (!isNaN(rows[i][k])) {\n                if (previous_was_number) return {\n                    valid: false,\n                    error_number: 8,\n                    error: errors[8]\n                };\n                sum_fields += parseInt(rows[i][k], 10);\n                previous_was_number = true;\n            } else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) return {\n                    valid: false,\n                    error_number: 9,\n                    error: errors[9]\n                };\n                sum_fields += 1;\n                previous_was_number = false;\n            }\n            if (sum_fields !== 8) return {\n                valid: false,\n                error_number: 10,\n                error: errors[10]\n            };\n        }\n        if (tokens[3][1] == \"3\" && tokens[1] == \"w\" || tokens[3][1] == \"6\" && tokens[1] == \"b\") return {\n            valid: false,\n            error_number: 11,\n            error: errors[11]\n        };\n        /* everything's okay! */ return {\n            valid: true,\n            error_number: 0,\n            error: errors[0]\n        };\n    }\n    function generate_fen() {\n        var empty = 0;\n        var fen = \"\";\n        for(var i = SQUARES.a8; i <= SQUARES.h1; i++){\n            if (board[i] == null) empty++;\n            else {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                var color = board[i].color;\n                var piece = board[i].type;\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            if (i + 1 & 0x88) {\n                if (empty > 0) fen += empty;\n                if (i !== SQUARES.h1) fen += \"/\";\n                empty = 0;\n                i += 8;\n            }\n        }\n        var cflags = \"\";\n        if (castling[WHITE] & BITS.KSIDE_CASTLE) cflags += \"K\";\n        if (castling[WHITE] & BITS.QSIDE_CASTLE) cflags += \"Q\";\n        if (castling[BLACK] & BITS.KSIDE_CASTLE) cflags += \"k\";\n        if (castling[BLACK] & BITS.QSIDE_CASTLE) cflags += \"q\";\n        /* do we have an empty castling flag? */ cflags = cflags || \"-\";\n        var epflags = ep_square === EMPTY ? \"-\" : algebraic(ep_square);\n        return [\n            fen,\n            turn,\n            cflags,\n            epflags,\n            half_moves,\n            move_number\n        ].join(\" \");\n    }\n    function set_header(args) {\n        for(var i = 0; i < args.length; i += 2)if (typeof args[i] === \"string\" && typeof args[i + 1] === \"string\") header[args[i]] = args[i + 1];\n        return header;\n    }\n    /* called when the initial board setup is changed with put() or remove().\r\n     * modifies the SetUp and FEN properties of the header object.  if the FEN is\r\n     * equal to the default position, the SetUp and FEN are deleted\r\n     * the setup is only updated if history.length is zero, ie moves haven't been\r\n     * made.\r\n     */ function update_setup(fen) {\n        if (history.length > 0) return;\n        if (fen !== DEFAULT_POSITION) {\n            header[\"SetUp\"] = \"1\";\n            header[\"FEN\"] = fen;\n        } else {\n            delete header[\"SetUp\"];\n            delete header[\"FEN\"];\n        }\n    }\n    function get(square) {\n        var piece = board[SQUARES[square]];\n        return piece ? {\n            type: piece.type,\n            color: piece.color\n        } : null;\n    }\n    function put(piece, square) {\n        /* check for valid piece object */ if (!(\"type\" in piece && \"color\" in piece)) return false;\n        /* check for piece */ if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) return false;\n        /* check for valid square */ if (!(square in SQUARES)) return false;\n        var sq = SQUARES[square];\n        /* don't let the user place more than one king */ if (piece.type == KING && !(kings[piece.color] == EMPTY || kings[piece.color] == sq)) return false;\n        board[sq] = {\n            type: piece.type,\n            color: piece.color\n        };\n        if (piece.type === KING) kings[piece.color] = sq;\n        update_setup(generate_fen());\n        return true;\n    }\n    function remove(square) {\n        var piece = get(square);\n        board[SQUARES[square]] = null;\n        if (piece && piece.type === KING) kings[piece.color] = EMPTY;\n        update_setup(generate_fen());\n        return piece;\n    }\n    function build_move(board, from, to, flags, promotion) {\n        var move = {\n            color: turn,\n            from: from,\n            to: to,\n            flags: flags,\n            piece: board[from].type\n        };\n        if (promotion) {\n            move.flags |= BITS.PROMOTION;\n            move.promotion = promotion;\n        }\n        if (board[to]) move.captured = board[to].type;\n        else if (flags & BITS.EP_CAPTURE) move.captured = PAWN;\n        return move;\n    }\n    function generate_moves(options) {\n        function add_move(board, moves, from, to, flags) {\n            /* if pawn promotion */ if (board[from].type === PAWN && (rank(to) === RANK_8 || rank(to) === RANK_1)) {\n                var pieces = [\n                    QUEEN,\n                    ROOK,\n                    BISHOP,\n                    KNIGHT\n                ];\n                for(var i = 0, len = pieces.length; i < len; i++)moves.push(build_move(board, from, to, flags, pieces[i]));\n            } else moves.push(build_move(board, from, to, flags));\n        }\n        var moves = [];\n        var us = turn;\n        var them = swap_color(us);\n        var second_rank = {\n            b: RANK_7,\n            w: RANK_2\n        };\n        var first_sq = SQUARES.a8;\n        var last_sq = SQUARES.h1;\n        var single_square = false;\n        /* do we want legal moves? */ var legal = typeof options !== \"undefined\" && \"legal\" in options ? options.legal : true;\n        /* are we generating moves for a single square? */ if (typeof options !== \"undefined\" && \"square\" in options) {\n            if (options.square in SQUARES) {\n                first_sq = last_sq = SQUARES[options.square];\n                single_square = true;\n            } else /* invalid square */ return [];\n        }\n        for(var i = first_sq; i <= last_sq; i++){\n            /* did we run off the end of the board */ if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            var piece = board[i];\n            if (piece == null || piece.color !== us) continue;\n            if (piece.type === PAWN) {\n                /* single square, non-capturing */ var square = i + PAWN_OFFSETS[us][0];\n                if (board[square] == null) {\n                    add_move(board, moves, i, square, BITS.NORMAL);\n                    /* double square */ var square = i + PAWN_OFFSETS[us][1];\n                    if (second_rank[us] === rank(i) && board[square] == null) add_move(board, moves, i, square, BITS.BIG_PAWN);\n                }\n                /* pawn captures */ for(j = 2; j < 4; j++){\n                    var square = i + PAWN_OFFSETS[us][j];\n                    if (square & 0x88) continue;\n                    if (board[square] != null && board[square].color === them) add_move(board, moves, i, square, BITS.CAPTURE);\n                    else if (square === ep_square) add_move(board, moves, i, ep_square, BITS.EP_CAPTURE);\n                }\n            } else for(var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++){\n                var offset = PIECE_OFFSETS[piece.type][j];\n                var square = i;\n                while(true){\n                    square += offset;\n                    if (square & 0x88) break;\n                    if (board[square] == null) add_move(board, moves, i, square, BITS.NORMAL);\n                    else {\n                        if (board[square].color === us) break;\n                        add_move(board, moves, i, square, BITS.CAPTURE);\n                        break;\n                    }\n                    /* break, if knight or king */ if (piece.type === \"n\" || piece.type === \"k\") break;\n                }\n            }\n        }\n        /* check for castling if: a) we're generating all moves, or b) we're doing\r\n       * single square move generation on the king's square\r\n       */ if (!single_square || last_sq === kings[us]) {\n            /* king-side castling */ if (castling[us] & BITS.KSIDE_CASTLE) {\n                var castling_from = kings[us];\n                var castling_to = castling_from + 2;\n                if (board[castling_from + 1] == null && board[castling_to] == null && !attacked(them, kings[us]) && !attacked(them, castling_from + 1) && !attacked(them, castling_to)) add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE);\n            }\n            /* queen-side castling */ if (castling[us] & BITS.QSIDE_CASTLE) {\n                var castling_from = kings[us];\n                var castling_to = castling_from - 2;\n                if (board[castling_from - 1] == null && board[castling_from - 2] == null && board[castling_from - 3] == null && !attacked(them, kings[us]) && !attacked(them, castling_from - 1) && !attacked(them, castling_to)) add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE);\n            }\n        }\n        /* return all pseudo-legal moves (this includes moves that allow the king\r\n       * to be captured)\r\n       */ if (!legal) return moves;\n        /* filter out illegal moves */ var legal_moves = [];\n        for(var i = 0, len = moves.length; i < len; i++){\n            make_move(moves[i]);\n            if (!king_attacked(us)) legal_moves.push(moves[i]);\n            undo_move();\n        }\n        return legal_moves;\n    }\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\r\n     * (SAN)\r\n     *\r\n     * @param {boolean} sloppy Use the sloppy SAN generator to work around over\r\n     * disambiguation bugs in Fritz and Chessbase.  See below:\r\n     *\r\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\r\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\r\n     * 4. ... Ne7 is technically the valid SAN\r\n     */ function move_to_san(move, sloppy) {\n        var output = \"\";\n        if (move.flags & BITS.KSIDE_CASTLE) output = \"O-O\";\n        else if (move.flags & BITS.QSIDE_CASTLE) output = \"O-O-O\";\n        else {\n            var disambiguator = get_disambiguator(move, sloppy);\n            if (move.piece !== PAWN) output += move.piece.toUpperCase() + disambiguator;\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) output += algebraic(move.from)[0];\n                output += \"x\";\n            }\n            output += algebraic(move.to);\n            if (move.flags & BITS.PROMOTION) output += \"=\" + move.promotion.toUpperCase();\n        }\n        make_move(move);\n        if (in_check()) {\n            if (in_checkmate()) output += \"#\";\n            else output += \"+\";\n        }\n        undo_move();\n        return output;\n    }\n    // parses all of the decorators out of a SAN string\n    function stripped_san(move) {\n        return move.replace(/=/, \"\").replace(/[+#]?[?!]*$/, \"\");\n    }\n    function attacked(color, square) {\n        for(var i = SQUARES.a8; i <= SQUARES.h1; i++){\n            /* did we run off the end of the board */ if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            /* if empty square or wrong color */ if (board[i] == null || board[i].color !== color) continue;\n            var piece = board[i];\n            var difference = i - square;\n            var index = difference + 119;\n            if (ATTACKS[index] & 1 << SHIFTS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === WHITE) return true;\n                    } else {\n                        if (piece.color === BLACK) return true;\n                    }\n                    continue;\n                }\n                /* if the piece is a knight or a king */ if (piece.type === \"n\" || piece.type === \"k\") return true;\n                var offset = RAYS[index];\n                var j = i + offset;\n                var blocked = false;\n                while(j !== square){\n                    if (board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked) return true;\n            }\n        }\n        return false;\n    }\n    function king_attacked(color) {\n        return attacked(swap_color(color), kings[color]);\n    }\n    function in_check() {\n        return king_attacked(turn);\n    }\n    function in_checkmate() {\n        return in_check() && generate_moves().length === 0;\n    }\n    function in_stalemate() {\n        return !in_check() && generate_moves().length === 0;\n    }\n    function insufficient_material() {\n        var pieces = {};\n        var bishops = [];\n        var num_pieces = 0;\n        var sq_color = 0;\n        for(var i = SQUARES.a8; i <= SQUARES.h1; i++){\n            sq_color = (sq_color + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            var piece = board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) bishops.push(sq_color);\n                num_pieces++;\n            }\n        }\n        /* k vs. k */ if (num_pieces === 2) return true;\n        else if (/* k vs. kn .... or .... k vs. kb */ num_pieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) return true;\n        else if (num_pieces === pieces[BISHOP] + 2) {\n            /* kb vs. kb where any number of bishops are all on the same color */ var sum = 0;\n            var len = bishops.length;\n            for(var i = 0; i < len; i++)sum += bishops[i];\n            if (sum === 0 || sum === len) return true;\n        }\n        return false;\n    }\n    function in_threefold_repetition() {\n        /* TODO: while this function is fine for casual use, a better\r\n       * implementation would use a Zobrist key (instead of FEN). the\r\n       * Zobrist key would be maintained in the make_move/undo_move functions,\r\n       * avoiding the costly that we do below.\r\n       */ var moves = [];\n        var positions = {};\n        var repetition = false;\n        while(true){\n            var move = undo_move();\n            if (!move) break;\n            moves.push(move);\n        }\n        while(true){\n            /* remove the last two fields in the FEN string, they're not needed\r\n         * when checking for draw by rep */ var fen = generate_fen().split(\" \").slice(0, 4).join(\" \");\n            /* has the position occurred three or move times */ positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n            if (positions[fen] >= 3) repetition = true;\n            if (!moves.length) break;\n            make_move(moves.pop());\n        }\n        return repetition;\n    }\n    function push(move) {\n        history.push({\n            move: move,\n            kings: {\n                b: kings.b,\n                w: kings.w\n            },\n            turn: turn,\n            castling: {\n                b: castling.b,\n                w: castling.w\n            },\n            ep_square: ep_square,\n            half_moves: half_moves,\n            move_number: move_number\n        });\n    }\n    function make_move(move) {\n        var us = turn;\n        var them = swap_color(us);\n        push(move);\n        board[move.to] = board[move.from];\n        board[move.from] = null;\n        /* if ep capture, remove the captured pawn */ if (move.flags & BITS.EP_CAPTURE) {\n            if (turn === BLACK) board[move.to - 16] = null;\n            else board[move.to + 16] = null;\n        }\n        /* if pawn promotion, replace with new piece */ if (move.flags & BITS.PROMOTION) board[move.to] = {\n            type: move.promotion,\n            color: us\n        };\n        /* if we moved the king */ if (board[move.to].type === KING) {\n            kings[board[move.to].color] = move.to;\n            /* if we castled, move the rook next to the king */ if (move.flags & BITS.KSIDE_CASTLE) {\n                var castling_to = move.to - 1;\n                var castling_from = move.to + 1;\n                board[castling_to] = board[castling_from];\n                board[castling_from] = null;\n            } else if (move.flags & BITS.QSIDE_CASTLE) {\n                var castling_to = move.to + 1;\n                var castling_from = move.to - 2;\n                board[castling_to] = board[castling_from];\n                board[castling_from] = null;\n            }\n            /* turn off castling */ castling[us] = \"\";\n        }\n        /* turn off castling if we move a rook */ if (castling[us]) {\n            for(var i = 0, len = ROOKS[us].length; i < len; i++)if (move.from === ROOKS[us][i].square && castling[us] & ROOKS[us][i].flag) {\n                castling[us] ^= ROOKS[us][i].flag;\n                break;\n            }\n        }\n        /* turn off castling if we capture a rook */ if (castling[them]) {\n            for(var i = 0, len = ROOKS[them].length; i < len; i++)if (move.to === ROOKS[them][i].square && castling[them] & ROOKS[them][i].flag) {\n                castling[them] ^= ROOKS[them][i].flag;\n                break;\n            }\n        }\n        /* if big pawn move, update the en passant square */ if (move.flags & BITS.BIG_PAWN) {\n            if (turn === \"b\") ep_square = move.to - 16;\n            else ep_square = move.to + 16;\n        } else ep_square = EMPTY;\n        /* reset the 50 move counter if a pawn is moved or a piece is captured */ if (move.piece === PAWN) half_moves = 0;\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) half_moves = 0;\n        else half_moves++;\n        if (turn === BLACK) move_number++;\n        turn = swap_color(turn);\n    }\n    function undo_move() {\n        var old = history.pop();\n        if (old == null) return null;\n        var move = old.move;\n        kings = old.kings;\n        turn = old.turn;\n        castling = old.castling;\n        ep_square = old.ep_square;\n        half_moves = old.half_moves;\n        move_number = old.move_number;\n        var us = turn;\n        var them = swap_color(turn);\n        board[move.from] = board[move.to];\n        board[move.from].type = move.piece // to undo any promotions\n        ;\n        board[move.to] = null;\n        if (move.flags & BITS.CAPTURE) board[move.to] = {\n            type: move.captured,\n            color: them\n        };\n        else if (move.flags & BITS.EP_CAPTURE) {\n            var index;\n            if (us === BLACK) index = move.to - 16;\n            else index = move.to + 16;\n            board[index] = {\n                type: PAWN,\n                color: them\n            };\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            var castling_to, castling_from;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castling_to = move.to + 1;\n                castling_from = move.to - 1;\n            } else if (move.flags & BITS.QSIDE_CASTLE) {\n                castling_to = move.to - 2;\n                castling_from = move.to + 1;\n            }\n            board[castling_to] = board[castling_from];\n            board[castling_from] = null;\n        }\n        return move;\n    }\n    /* this function is used to uniquely identify ambiguous moves */ function get_disambiguator(move, sloppy) {\n        var moves = generate_moves({\n            legal: !sloppy\n        });\n        var from = move.from;\n        var to = move.to;\n        var piece = move.piece;\n        var ambiguities = 0;\n        var same_rank = 0;\n        var same_file = 0;\n        for(var i = 0, len = moves.length; i < len; i++){\n            var ambig_from = moves[i].from;\n            var ambig_to = moves[i].to;\n            var ambig_piece = moves[i].piece;\n            /* if a move of the same piece type ends on the same to square, we'll\r\n         * need to add a disambiguator to the algebraic notation\r\n         */ if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n                ambiguities++;\n                if (rank(from) === rank(ambig_from)) same_rank++;\n                if (file(from) === file(ambig_from)) same_file++;\n            }\n        }\n        if (ambiguities > 0) {\n            /* if there exists a similar moving piece on the same rank and file as\r\n         * the move in question, use the square as the disambiguator\r\n         */ if (same_rank > 0 && same_file > 0) return algebraic(from);\n            else if (same_file > 0) /* if the moving piece rests on the same file, use the rank symbol as the\r\n           * disambiguator\r\n           */ return algebraic(from).charAt(1);\n            else /* else use the file symbol */ return algebraic(from).charAt(0);\n        }\n        return \"\";\n    }\n    function ascii() {\n        var s = \"   +------------------------+\\n\";\n        for(var i = SQUARES.a8; i <= SQUARES.h1; i++){\n            /* display the rank */ if (file(i) === 0) s += \" \" + \"87654321\"[rank(i)] + \" |\";\n            /* empty piece */ if (board[i] == null) s += \" . \";\n            else {\n                var piece = board[i].type;\n                var color = board[i].color;\n                var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += \" \" + symbol + \" \";\n            }\n            if (i + 1 & 0x88) {\n                s += \"|\\n\";\n                i += 8;\n            }\n        }\n        s += \"   +------------------------+\\n\";\n        s += \"     a  b  c  d  e  f  g  h\\n\";\n        return s;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    function move_from_san(move, sloppy) {\n        // strip off any move decorations: e.g Nf3+?!\n        var clean_move = stripped_san(move);\n        // if we're using the sloppy parser run a regex to grab piece, to, and from\n        // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\n        if (sloppy) {\n            var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                var piece = matches[1];\n                var from = matches[2];\n                var to = matches[3];\n                var promotion = matches[4];\n            }\n        }\n        var moves = generate_moves();\n        for(var i = 0, len = moves.length; i < len; i++){\n            // try the strict parser first, then the sloppy parser if requested\n            // by the user\n            if (clean_move === stripped_san(move_to_san(moves[i])) || sloppy && clean_move === stripped_san(move_to_san(moves[i], true))) return moves[i];\n            else {\n                if (matches && (!piece || piece.toLowerCase() == moves[i].piece) && SQUARES[from] == moves[i].from && SQUARES[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) return moves[i];\n            }\n        }\n        return null;\n    }\n    /*****************************************************************************\r\n     * UTILITY FUNCTIONS\r\n     ****************************************************************************/ function rank(i) {\n        return i >> 4;\n    }\n    function file(i) {\n        return i & 15;\n    }\n    function algebraic(i) {\n        var f = file(i), r = rank(i);\n        return \"abcdefgh\".substring(f, f + 1) + \"87654321\".substring(r, r + 1);\n    }\n    function swap_color(c) {\n        return c === WHITE ? BLACK : WHITE;\n    }\n    function is_digit(c) {\n        return \"0123456789\".indexOf(c) !== -1;\n    }\n    /* pretty = external move object */ function make_pretty(ugly_move) {\n        var move = clone(ugly_move);\n        move.san = move_to_san(move, false);\n        move.to = algebraic(move.to);\n        move.from = algebraic(move.from);\n        var flags = \"\";\n        for(var flag in BITS)if (BITS[flag] & move.flags) flags += FLAGS[flag];\n        move.flags = flags;\n        return move;\n    }\n    function clone(obj) {\n        var dupe = obj instanceof Array ? [] : {};\n        for(var property in obj)if (typeof property === \"object\") dupe[property] = clone(obj[property]);\n        else dupe[property] = obj[property];\n        return dupe;\n    }\n    function trim(str) {\n        return str.replace(/^\\s+|\\s+$/g, \"\");\n    }\n    /*****************************************************************************\r\n     * DEBUGGING UTILITIES\r\n     ****************************************************************************/ function perft(depth) {\n        var moves = generate_moves({\n            legal: false\n        });\n        var nodes = 0;\n        var color = turn;\n        for(var i = 0, len = moves.length; i < len; i++){\n            make_move(moves[i]);\n            if (!king_attacked(color)) {\n                if (depth - 1 > 0) {\n                    var child_nodes = perft(depth - 1);\n                    nodes += child_nodes;\n                } else nodes++;\n            }\n            undo_move();\n        }\n        return nodes;\n    }\n    return {\n        /***************************************************************************\r\n       * PUBLIC CONSTANTS (is there a better way to do this?)\r\n       **************************************************************************/ WHITE: WHITE,\n        BLACK: BLACK,\n        PAWN: PAWN,\n        KNIGHT: KNIGHT,\n        BISHOP: BISHOP,\n        ROOK: ROOK,\n        QUEEN: QUEEN,\n        KING: KING,\n        SQUARES: function() {\n            /* from the ECMA-262 spec (section 12.6.4):\r\n         * \"The mechanics of enumerating the properties ... is\r\n         * implementation dependent\"\r\n         * so: for (var sq in SQUARES) { keys.push(sq); } might not be\r\n         * ordered correctly\r\n         */ var keys = [];\n            for(var i = SQUARES.a8; i <= SQUARES.h1; i++){\n                if (i & 0x88) {\n                    i += 7;\n                    continue;\n                }\n                keys.push(algebraic(i));\n            }\n            return keys;\n        }(),\n        FLAGS: FLAGS,\n        /***************************************************************************\r\n       * PUBLIC API\r\n       **************************************************************************/ load: function(fen) {\n            return load(fen);\n        },\n        reset: function() {\n            return reset();\n        },\n        moves: function(options) {\n            /* The internal representation of a chess move is in 0x88 format, and\r\n         * not meant to be human-readable.  The code below converts the 0x88\r\n         * square coordinates to algebraic coordinates.  It also prunes an\r\n         * unnecessary move keys resulting from a verbose call.\r\n         */ var ugly_moves = generate_moves(options);\n            var moves = [];\n            for(var i = 0, len = ugly_moves.length; i < len; i++)/* does the user want a full move object (most likely not), or just\r\n           * SAN\r\n           */ if (typeof options !== \"undefined\" && \"verbose\" in options && options.verbose) moves.push(make_pretty(ugly_moves[i]));\n            else moves.push(move_to_san(ugly_moves[i], false));\n            return moves;\n        },\n        ugly_moves: function(options) {\n            var ugly_moves = generate_moves(options);\n            return ugly_moves;\n        },\n        in_check: function() {\n            return in_check();\n        },\n        in_checkmate: function() {\n            return in_checkmate();\n        },\n        in_stalemate: function() {\n            return in_stalemate();\n        },\n        in_draw: function() {\n            return half_moves >= 100 || in_stalemate() || insufficient_material() || in_threefold_repetition();\n        },\n        insufficient_material: function() {\n            return insufficient_material();\n        },\n        in_threefold_repetition: function() {\n            return in_threefold_repetition();\n        },\n        game_over: function() {\n            return half_moves >= 100 || in_checkmate() || in_stalemate() || insufficient_material() || in_threefold_repetition();\n        },\n        validate_fen: function(fen) {\n            return validate_fen(fen);\n        },\n        fen: function() {\n            return generate_fen();\n        },\n        board: function() {\n            var output = [], row = [];\n            for(var i = SQUARES.a8; i <= SQUARES.h1; i++){\n                if (board[i] == null) row.push(null);\n                else row.push({\n                    type: board[i].type,\n                    color: board[i].color\n                });\n                if (i + 1 & 0x88) {\n                    output.push(row);\n                    row = [];\n                    i += 8;\n                }\n            }\n            return output;\n        },\n        pgn: function(options) {\n            /* using the specification from http://www.chessclub.com/help/PGN-spec\r\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\r\n         */ var newline = typeof options === \"object\" && typeof options.newline_char === \"string\" ? options.newline_char : \"\\n\";\n            var max_width = typeof options === \"object\" && typeof options.max_width === \"number\" ? options.max_width : 0;\n            var result = [];\n            var header_exists = false;\n            /* add the PGN header headerrmation */ for(var i in header){\n                /* TODO: order of enumerated properties in header object is not\r\n           * guaranteed, see ECMA-262 spec (section 12.6.4)\r\n           */ result.push(\"[\" + i + ' \"' + header[i] + '\"]' + newline);\n                header_exists = true;\n            }\n            if (header_exists && history.length) result.push(newline);\n            var append_comment = function(move_string) {\n                var comment = comments[generate_fen()];\n                if (typeof comment !== \"undefined\") {\n                    var delimiter = move_string.length > 0 ? \" \" : \"\";\n                    move_string = `${move_string}${delimiter}{${comment}}`;\n                }\n                return move_string;\n            };\n            /* pop all of history onto reversed_history */ var reversed_history = [];\n            while(history.length > 0)reversed_history.push(undo_move());\n            var moves = [];\n            var move_string = \"\";\n            /* special case of a commented starting position with no moves */ if (reversed_history.length === 0) moves.push(append_comment(\"\"));\n            /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */ while(reversed_history.length > 0){\n                move_string = append_comment(move_string);\n                var move = reversed_history.pop();\n                /* if the position started with black to move, start PGN with 1. ... */ if (!history.length && move.color === \"b\") move_string = move_number + \". ...\";\n                else if (move.color === \"w\") {\n                    /* store the previous generated move_string if we have one */ if (move_string.length) moves.push(move_string);\n                    move_string = move_number + \".\";\n                }\n                move_string = move_string + \" \" + move_to_san(move, false);\n                make_move(move);\n            }\n            /* are there any other leftover moves? */ if (move_string.length) moves.push(append_comment(move_string));\n            /* is there a result? */ if (typeof header.Result !== \"undefined\") moves.push(header.Result);\n            /* history should be back to what it was before we started generating PGN,\r\n         * so join together moves\r\n         */ if (max_width === 0) return result.join(\"\") + moves.join(\" \");\n            var strip = function() {\n                if (result.length > 0 && result[result.length - 1] === \" \") {\n                    result.pop();\n                    return true;\n                }\n                return false;\n            };\n            /* NB: this does not preserve comment whitespace. */ var wrap_comment = function(width, move) {\n                for (var token of move.split(\" \")){\n                    if (!token) continue;\n                    if (width + token.length > max_width) {\n                        while(strip())width--;\n                        result.push(newline);\n                        width = 0;\n                    }\n                    result.push(token);\n                    width += token.length;\n                    result.push(\" \");\n                    width++;\n                }\n                if (strip()) width--;\n                return width;\n            };\n            /* wrap the PGN output at max_width */ var current_width = 0;\n            for(var i = 0; i < moves.length; i++){\n                if (current_width + moves[i].length > max_width) {\n                    if (moves[i].includes(\"{\")) {\n                        current_width = wrap_comment(current_width, moves[i]);\n                        continue;\n                    }\n                }\n                /* if the current move will push past max_width */ if (current_width + moves[i].length > max_width && i !== 0) {\n                    /* don't end the line with whitespace */ if (result[result.length - 1] === \" \") result.pop();\n                    result.push(newline);\n                    current_width = 0;\n                } else if (i !== 0) {\n                    result.push(\" \");\n                    current_width++;\n                }\n                result.push(moves[i]);\n                current_width += moves[i].length;\n            }\n            return result.join(\"\");\n        },\n        load_pgn: function(pgn, options) {\n            // allow the user to specify the sloppy move parser to work around over\n            // disambiguation bugs in Fritz and Chessbase\n            var sloppy = typeof options !== \"undefined\" && \"sloppy\" in options ? options.sloppy : false;\n            function mask(str) {\n                return str.replace(/\\\\/g, \"\\\\\");\n            }\n            function has_keys(object) {\n                for(var key in object)return true;\n                return false;\n            }\n            function parse_pgn_header(header, options) {\n                var newline_char = typeof options === \"object\" && typeof options.newline_char === \"string\" ? options.newline_char : \"\\r?\\n\";\n                var header_obj = {};\n                var headers = header.split(new RegExp(mask(newline_char)));\n                var key = \"\";\n                var value = \"\";\n                for(var i = 0; i < headers.length; i++){\n                    key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, \"$1\");\n                    value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\ *\\]$/, \"$1\");\n                    if (trim(key).length > 0) header_obj[key] = value;\n                }\n                return header_obj;\n            }\n            var newline_char = typeof options === \"object\" && typeof options.newline_char === \"string\" ? options.newline_char : \"\\r?\\n\";\n            // RegExp to split header. Takes advantage of the fact that header and movetext\n            // will always have a blank line between them (ie, two newline_char's).\n            // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\n            var header_regex = new RegExp(\"^(\\\\[((?:\" + mask(newline_char) + \")|.)*\\\\])\" + \"(?:\" + mask(newline_char) + \"){2}\");\n            // If no header given, begin with moves.\n            var header_string = header_regex.test(pgn) ? header_regex.exec(pgn)[1] : \"\";\n            // Put the board in the starting position\n            reset();\n            /* parse PGN header */ var headers = parse_pgn_header(header_string, options);\n            for(var key in headers)set_header([\n                key,\n                headers[key]\n            ]);\n            /* load the starting position indicated by [Setup '1'] and\r\n         * [FEN position] */ if (headers[\"SetUp\"] === \"1\") {\n                if (!(\"FEN\" in headers && load(headers[\"FEN\"], true))) // second argument to load: don't clear the headers\n                return false;\n            }\n            /* NB: the regexes below that delete move numbers, recursive\r\n         * annotations, and numeric annotation glyphs may also match\r\n         * text in comments. To prevent this, we transform comments\r\n         * by hex-encoding them in place and decoding them again after\r\n         * the other tokens have been deleted.\r\n         *\r\n         * While the spec states that PGN files should be ASCII encoded,\r\n         * we use {en,de}codeURIComponent here to support arbitrary UTF8\r\n         * as a convenience for modern users */ var to_hex = function(string) {\n                return Array.from(string).map(function(c) {\n                    /* encodeURI doesn't transform most ASCII characters,\r\n               * so we handle these ourselves */ return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/\\%/g, \"\").toLowerCase();\n                }).join(\"\");\n            };\n            var from_hex = function(string) {\n                return string.length == 0 ? \"\" : decodeURIComponent(\"%\" + string.match(/.{1,2}/g).join(\"%\"));\n            };\n            var encode_comment = function(string) {\n                string = string.replace(new RegExp(mask(newline_char), \"g\"), \" \");\n                return `{${to_hex(string.slice(1, string.length - 1))}}`;\n            };\n            var decode_comment = function(string) {\n                if (string.startsWith(\"{\") && string.endsWith(\"}\")) return from_hex(string.slice(1, string.length - 1));\n            };\n            /* delete header to get the moves */ var ms = pgn.replace(header_string, \"\").replace(/* encode comments so they don't get deleted below */ new RegExp(`(\\{[^}]*\\})+?|;([^${mask(newline_char)}]*)`, \"g\"), function(match, bracket, semicolon) {\n                return bracket !== undefined ? encode_comment(bracket) : \" \" + encode_comment(`{${semicolon.slice(1)}}`);\n            }).replace(new RegExp(mask(newline_char), \"g\"), \" \");\n            /* delete recursive annotation variations */ var rav_regex = /(\\([^\\(\\)]+\\))+?/g;\n            while(rav_regex.test(ms))ms = ms.replace(rav_regex, \"\");\n            /* delete move numbers */ ms = ms.replace(/\\d+\\.(\\.\\.)?/g, \"\");\n            /* delete ... indicating black to move */ ms = ms.replace(/\\.\\.\\./g, \"\");\n            /* delete numeric annotation glyphs */ ms = ms.replace(/\\$\\d+/g, \"\");\n            /* trim and get array of moves */ var moves = trim(ms).split(new RegExp(/\\s+/));\n            /* delete empty entries */ moves = moves.join(\",\").replace(/,,+/g, \",\").split(\",\");\n            var move = \"\";\n            for(var half_move = 0; half_move < moves.length - 1; half_move++){\n                var comment = decode_comment(moves[half_move]);\n                if (comment !== undefined) {\n                    comments[generate_fen()] = comment;\n                    continue;\n                }\n                move = move_from_san(moves[half_move], sloppy);\n                /* move not possible! (don't clear the board to examine to show the\r\n           * latest valid position)\r\n           */ if (move == null) return false;\n                else make_move(move);\n            }\n            comment = decode_comment(moves[moves.length - 1]);\n            if (comment !== undefined) {\n                comments[generate_fen()] = comment;\n                moves.pop();\n            }\n            /* examine last move */ move = moves[moves.length - 1];\n            if (POSSIBLE_RESULTS.indexOf(move) > -1) {\n                if (has_keys(header) && typeof header.Result === \"undefined\") set_header([\n                    \"Result\",\n                    move\n                ]);\n            } else {\n                move = move_from_san(move, sloppy);\n                if (move == null) return false;\n                else make_move(move);\n            }\n            return true;\n        },\n        header: function() {\n            return set_header(arguments);\n        },\n        ascii: function() {\n            return ascii();\n        },\n        turn: function() {\n            return turn;\n        },\n        move: function(move, options) {\n            /* The move function can be called with in the following parameters:\r\n         *\r\n         * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\r\n         *\r\n         * .move({ from: 'h7', <- where the 'move' is a move object (additional\r\n         *         to :'h8',      fields are ignored)\r\n         *         promotion: 'q',\r\n         *      })\r\n         */ // allow the user to specify the sloppy move parser to work around over\n            // disambiguation bugs in Fritz and Chessbase\n            var sloppy = typeof options !== \"undefined\" && \"sloppy\" in options ? options.sloppy : false;\n            var move_obj = null;\n            if (typeof move === \"string\") move_obj = move_from_san(move, sloppy);\n            else if (typeof move === \"object\") {\n                var moves = generate_moves();\n                /* convert the pretty move object to an ugly move object */ for(var i = 0, len = moves.length; i < len; i++)if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!(\"promotion\" in moves[i]) || move.promotion === moves[i].promotion)) {\n                    move_obj = moves[i];\n                    break;\n                }\n            }\n            /* failed to find move */ if (!move_obj) return null;\n            /* need to make a copy of move because we can't generate SAN after the\r\n         * move is made\r\n         */ var pretty_move = make_pretty(move_obj);\n            make_move(move_obj);\n            return pretty_move;\n        },\n        ugly_move: function(move_obj, options) {\n            var pretty_move = make_pretty(move_obj);\n            make_move(move_obj);\n            return pretty_move;\n        },\n        undo: function() {\n            var move = undo_move();\n            return move ? make_pretty(move) : null;\n        },\n        clear: function() {\n            return clear();\n        },\n        put: function(piece, square) {\n            return put(piece, square);\n        },\n        get: function(square) {\n            return get(square);\n        },\n        remove: function(square) {\n            return remove(square);\n        },\n        perft: function(depth) {\n            return perft(depth);\n        },\n        square_color: function(square) {\n            if (square in SQUARES) {\n                var sq_0x88 = SQUARES[square];\n                return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? \"light\" : \"dark\";\n            }\n            return null;\n        },\n        history: function(options) {\n            var reversed_history = [];\n            var move_history = [];\n            var verbose = typeof options !== \"undefined\" && \"verbose\" in options && options.verbose;\n            while(history.length > 0)reversed_history.push(undo_move());\n            while(reversed_history.length > 0){\n                var move = reversed_history.pop();\n                if (verbose) move_history.push(make_pretty(move));\n                else move_history.push(move_to_san(move));\n                make_move(move);\n            }\n            return move_history;\n        },\n        get_comment: function() {\n            return comments[generate_fen()];\n        },\n        set_comment: function(comment) {\n            comments[generate_fen()] = comment.replace(\"{\", \"[\").replace(\"}\", \"]\");\n        },\n        delete_comment: function() {\n            var comment = comments[generate_fen()];\n            delete comments[generate_fen()];\n            return comment;\n        },\n        get_comments: function() {\n            prune_comments();\n            return Object.keys(comments).map(function(fen) {\n                return {\n                    fen: fen,\n                    comment: comments[fen]\n                };\n            });\n        },\n        delete_comments: function() {\n            prune_comments();\n            return Object.keys(comments).map(function(fen) {\n                var comment = comments[fen];\n                delete comments[fen];\n                return {\n                    fen: fen,\n                    comment: comment\n                };\n            });\n        }\n    };\n};\n/* export Chess object if using node or any other CommonJS compatible\r\n   * environment */ if (typeof exports !== \"undefined\") exports.Chess = Chess;\n/* export Chess object for any RequireJS compatible environment */ if (typeof define !== \"undefined\") define(function() {\n    return Chess;\n});\n\n//# sourceMappingURL=chess.bef3132b.js.map\n","/*\r\n * Copyright (c) 2020, Jeff Hlywa (jhlywa@gmail.com)\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n *----------------------------------------------------------------------------*/\r\n\r\nvar Chess = function(fen) {\r\n    var BLACK = 'b'\r\n    var WHITE = 'w'\r\n  \r\n    var EMPTY = -1\r\n  \r\n    var PAWN = 'p'\r\n    var KNIGHT = 'n'\r\n    var BISHOP = 'b'\r\n    var ROOK = 'r'\r\n    var QUEEN = 'q'\r\n    var KING = 'k'\r\n  \r\n    var SYMBOLS = 'pnbrqkPNBRQK'\r\n  \r\n    var DEFAULT_POSITION =\r\n      'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\r\n  \r\n    var POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*']\r\n  \r\n    var PAWN_OFFSETS = {\r\n      b: [16, 32, 17, 15],\r\n      w: [-16, -32, -17, -15]\r\n    }\r\n  \r\n    var PIECE_OFFSETS = {\r\n      n: [-18, -33, -31, -14, 18, 33, 31, 14],\r\n      b: [-17, -15, 17, 15],\r\n      r: [-16, 1, 16, -1],\r\n      q: [-17, -16, -15, 1, 17, 16, 15, -1],\r\n      k: [-17, -16, -15, 1, 17, 16, 15, -1]\r\n    }\r\n  \r\n    // prettier-ignore\r\n    var ATTACKS = [\r\n      20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\r\n       0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\r\n       0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\r\n       0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\r\n       0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\r\n       0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\r\n       0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n      24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\r\n       0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n       0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\r\n       0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\r\n       0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\r\n       0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\r\n       0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\r\n      20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\r\n    ];\r\n  \r\n    // prettier-ignore\r\n    var RAYS = [\r\n       17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\r\n        0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\r\n        0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\r\n        0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\r\n        0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\r\n        0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\r\n        0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\r\n        1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\r\n        0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\r\n        0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\r\n        0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\r\n        0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\r\n        0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\r\n        0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\r\n      -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\r\n    ];\r\n  \r\n    var SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 }\r\n  \r\n    var FLAGS = {\r\n      NORMAL: 'n',\r\n      CAPTURE: 'c',\r\n      BIG_PAWN: 'b',\r\n      EP_CAPTURE: 'e',\r\n      PROMOTION: 'p',\r\n      KSIDE_CASTLE: 'k',\r\n      QSIDE_CASTLE: 'q'\r\n    }\r\n  \r\n    var BITS = {\r\n      NORMAL: 1,\r\n      CAPTURE: 2,\r\n      BIG_PAWN: 4,\r\n      EP_CAPTURE: 8,\r\n      PROMOTION: 16,\r\n      KSIDE_CASTLE: 32,\r\n      QSIDE_CASTLE: 64\r\n    }\r\n  \r\n    var RANK_1 = 7\r\n    var RANK_2 = 6\r\n    var RANK_3 = 5\r\n    var RANK_4 = 4\r\n    var RANK_5 = 3\r\n    var RANK_6 = 2\r\n    var RANK_7 = 1\r\n    var RANK_8 = 0\r\n  \r\n    // prettier-ignore\r\n    var SQUARES = {\r\n      a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\r\n      a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\r\n      a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\r\n      a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\r\n      a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\r\n      a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\r\n      a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\r\n      a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\r\n    };\r\n  \r\n    var ROOKS = {\r\n      w: [\r\n        { square: SQUARES.a1, flag: BITS.QSIDE_CASTLE },\r\n        { square: SQUARES.h1, flag: BITS.KSIDE_CASTLE }\r\n      ],\r\n      b: [\r\n        { square: SQUARES.a8, flag: BITS.QSIDE_CASTLE },\r\n        { square: SQUARES.h8, flag: BITS.KSIDE_CASTLE }\r\n      ]\r\n    }\r\n  \r\n    var board = new Array(128)\r\n    var kings = { w: EMPTY, b: EMPTY }\r\n    var turn = WHITE\r\n    var castling = { w: 0, b: 0 }\r\n    var ep_square = EMPTY\r\n    var half_moves = 0\r\n    var move_number = 1\r\n    var history = []\r\n    var header = {}\r\n    var comments = {}\r\n  \r\n    /* if the user passes in a fen string, load it, else default to\r\n     * starting position\r\n     */\r\n    if (typeof fen === 'undefined') {\r\n      load(DEFAULT_POSITION)\r\n    } else {\r\n      load(fen)\r\n    }\r\n  \r\n    function clear(keep_headers) {\r\n      if (typeof keep_headers === 'undefined') {\r\n        keep_headers = false\r\n      }\r\n  \r\n      board = new Array(128)\r\n      kings = { w: EMPTY, b: EMPTY }\r\n      turn = WHITE\r\n      castling = { w: 0, b: 0 }\r\n      ep_square = EMPTY\r\n      half_moves = 0\r\n      move_number = 1\r\n      history = []\r\n      if (!keep_headers) header = {}\r\n      comments = {}\r\n      update_setup(generate_fen())\r\n    }\r\n  \r\n    function prune_comments() {\r\n      var reversed_history = [];\r\n      var current_comments = {};\r\n      var copy_comment = function(fen) {\r\n        if (fen in comments) {\r\n          current_comments[fen] = comments[fen];\r\n        }\r\n      };\r\n      while (history.length > 0) {\r\n        reversed_history.push(undo_move());\r\n      }\r\n      copy_comment(generate_fen());\r\n      while (reversed_history.length > 0) {\r\n        make_move(reversed_history.pop());\r\n        copy_comment(generate_fen());\r\n      }\r\n      comments = current_comments;\r\n    }\r\n  \r\n    function reset() {\r\n      load(DEFAULT_POSITION)\r\n    }\r\n  \r\n    function load(fen, keep_headers) {\r\n      if (typeof keep_headers === 'undefined') {\r\n        keep_headers = false\r\n      }\r\n  \r\n      var tokens = fen.split(/\\s+/)\r\n      var position = tokens[0]\r\n      var square = 0\r\n  \r\n      if (!validate_fen(fen).valid) {\r\n        return false\r\n      }\r\n  \r\n      clear(keep_headers)\r\n  \r\n      for (var i = 0; i < position.length; i++) {\r\n        var piece = position.charAt(i)\r\n  \r\n        if (piece === '/') {\r\n          square += 8\r\n        } else if (is_digit(piece)) {\r\n          square += parseInt(piece, 10)\r\n        } else {\r\n          var color = piece < 'a' ? WHITE : BLACK\r\n          put({ type: piece.toLowerCase(), color: color }, algebraic(square))\r\n          square++\r\n        }\r\n      }\r\n  \r\n      turn = tokens[1]\r\n  \r\n      if (tokens[2].indexOf('K') > -1) {\r\n        castling.w |= BITS.KSIDE_CASTLE\r\n      }\r\n      if (tokens[2].indexOf('Q') > -1) {\r\n        castling.w |= BITS.QSIDE_CASTLE\r\n      }\r\n      if (tokens[2].indexOf('k') > -1) {\r\n        castling.b |= BITS.KSIDE_CASTLE\r\n      }\r\n      if (tokens[2].indexOf('q') > -1) {\r\n        castling.b |= BITS.QSIDE_CASTLE\r\n      }\r\n  \r\n      ep_square = tokens[3] === '-' ? EMPTY : SQUARES[tokens[3]]\r\n      half_moves = parseInt(tokens[4], 10)\r\n      move_number = parseInt(tokens[5], 10)\r\n  \r\n      update_setup(generate_fen())\r\n  \r\n      return true\r\n    }\r\n  \r\n    /* TODO: this function is pretty much crap - it validates structure but\r\n     * completely ignores content (e.g. doesn't verify that each side has a king)\r\n     * ... we should rewrite this, and ditch the silly error_number field while\r\n     * we're at it\r\n     */\r\n    function validate_fen(fen) {\r\n      var errors = {\r\n        0: 'No errors.',\r\n        1: 'FEN string must contain six space-delimited fields.',\r\n        2: '6th field (move number) must be a positive integer.',\r\n        3: '5th field (half move counter) must be a non-negative integer.',\r\n        4: '4th field (en-passant square) is invalid.',\r\n        5: '3rd field (castling availability) is invalid.',\r\n        6: '2nd field (side to move) is invalid.',\r\n        7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\r\n        8: '1st field (piece positions) is invalid [consecutive numbers].',\r\n        9: '1st field (piece positions) is invalid [invalid piece].',\r\n        10: '1st field (piece positions) is invalid [row too large].',\r\n        11: 'Illegal en-passant square'\r\n      }\r\n  \r\n      /* 1st criterion: 6 space-seperated fields? */\r\n      var tokens = fen.split(/\\s+/)\r\n      if (tokens.length !== 6) {\r\n        return { valid: false, error_number: 1, error: errors[1] }\r\n      }\r\n  \r\n      /* 2nd criterion: move number field is a integer value > 0? */\r\n      if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\r\n        return { valid: false, error_number: 2, error: errors[2] }\r\n      }\r\n  \r\n      /* 3rd criterion: half move counter is an integer >= 0? */\r\n      if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\r\n        return { valid: false, error_number: 3, error: errors[3] }\r\n      }\r\n  \r\n      /* 4th criterion: 4th field is a valid e.p.-string? */\r\n      if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\r\n        return { valid: false, error_number: 4, error: errors[4] }\r\n      }\r\n  \r\n      /* 5th criterion: 3th field is a valid castle-string? */\r\n      if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\r\n        return { valid: false, error_number: 5, error: errors[5] }\r\n      }\r\n  \r\n      /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\r\n      if (!/^(w|b)$/.test(tokens[1])) {\r\n        return { valid: false, error_number: 6, error: errors[6] }\r\n      }\r\n  \r\n      /* 7th criterion: 1st field contains 8 rows? */\r\n      var rows = tokens[0].split('/')\r\n      if (rows.length !== 8) {\r\n        return { valid: false, error_number: 7, error: errors[7] }\r\n      }\r\n  \r\n      /* 8th criterion: every row is valid? */\r\n      for (var i = 0; i < rows.length; i++) {\r\n        /* check for right sum of fields AND not two numbers in succession */\r\n        var sum_fields = 0\r\n        var previous_was_number = false\r\n  \r\n        for (var k = 0; k < rows[i].length; k++) {\r\n          if (!isNaN(rows[i][k])) {\r\n            if (previous_was_number) {\r\n              return { valid: false, error_number: 8, error: errors[8] }\r\n            }\r\n            sum_fields += parseInt(rows[i][k], 10)\r\n            previous_was_number = true\r\n          } else {\r\n            if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\r\n              return { valid: false, error_number: 9, error: errors[9] }\r\n            }\r\n            sum_fields += 1\r\n            previous_was_number = false\r\n          }\r\n        }\r\n        if (sum_fields !== 8) {\r\n          return { valid: false, error_number: 10, error: errors[10] }\r\n        }\r\n      }\r\n  \r\n      if (\r\n        (tokens[3][1] == '3' && tokens[1] == 'w') ||\r\n        (tokens[3][1] == '6' && tokens[1] == 'b')\r\n      ) {\r\n        return { valid: false, error_number: 11, error: errors[11] }\r\n      }\r\n  \r\n      /* everything's okay! */\r\n      return { valid: true, error_number: 0, error: errors[0] }\r\n    }\r\n  \r\n    function generate_fen() {\r\n      var empty = 0\r\n      var fen = ''\r\n  \r\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\r\n        if (board[i] == null) {\r\n          empty++\r\n        } else {\r\n          if (empty > 0) {\r\n            fen += empty\r\n            empty = 0\r\n          }\r\n          var color = board[i].color\r\n          var piece = board[i].type\r\n  \r\n          fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\r\n        }\r\n  \r\n        if ((i + 1) & 0x88) {\r\n          if (empty > 0) {\r\n            fen += empty\r\n          }\r\n  \r\n          if (i !== SQUARES.h1) {\r\n            fen += '/'\r\n          }\r\n  \r\n          empty = 0\r\n          i += 8\r\n        }\r\n      }\r\n  \r\n      var cflags = ''\r\n      if (castling[WHITE] & BITS.KSIDE_CASTLE) {\r\n        cflags += 'K'\r\n      }\r\n      if (castling[WHITE] & BITS.QSIDE_CASTLE) {\r\n        cflags += 'Q'\r\n      }\r\n      if (castling[BLACK] & BITS.KSIDE_CASTLE) {\r\n        cflags += 'k'\r\n      }\r\n      if (castling[BLACK] & BITS.QSIDE_CASTLE) {\r\n        cflags += 'q'\r\n      }\r\n  \r\n      /* do we have an empty castling flag? */\r\n      cflags = cflags || '-'\r\n      var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square)\r\n  \r\n      return [fen, turn, cflags, epflags, half_moves, move_number].join(' ')\r\n    }\r\n  \r\n    function set_header(args) {\r\n      for (var i = 0; i < args.length; i += 2) {\r\n        if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\r\n          header[args[i]] = args[i + 1]\r\n        }\r\n      }\r\n      return header\r\n    }\r\n  \r\n    /* called when the initial board setup is changed with put() or remove().\r\n     * modifies the SetUp and FEN properties of the header object.  if the FEN is\r\n     * equal to the default position, the SetUp and FEN are deleted\r\n     * the setup is only updated if history.length is zero, ie moves haven't been\r\n     * made.\r\n     */\r\n    function update_setup(fen) {\r\n      if (history.length > 0) return\r\n  \r\n      if (fen !== DEFAULT_POSITION) {\r\n        header['SetUp'] = '1'\r\n        header['FEN'] = fen\r\n      } else {\r\n        delete header['SetUp']\r\n        delete header['FEN']\r\n      }\r\n    }\r\n  \r\n    function get(square) {\r\n      var piece = board[SQUARES[square]]\r\n      return piece ? { type: piece.type, color: piece.color } : null\r\n    }\r\n  \r\n    function put(piece, square) {\r\n      /* check for valid piece object */\r\n      if (!('type' in piece && 'color' in piece)) {\r\n        return false\r\n      }\r\n  \r\n      /* check for piece */\r\n      if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\r\n        return false\r\n      }\r\n  \r\n      /* check for valid square */\r\n      if (!(square in SQUARES)) {\r\n        return false\r\n      }\r\n  \r\n      var sq = SQUARES[square]\r\n  \r\n      /* don't let the user place more than one king */\r\n      if (\r\n        piece.type == KING &&\r\n        !(kings[piece.color] == EMPTY || kings[piece.color] == sq)\r\n      ) {\r\n        return false\r\n      }\r\n  \r\n      board[sq] = { type: piece.type, color: piece.color }\r\n      if (piece.type === KING) {\r\n        kings[piece.color] = sq\r\n      }\r\n  \r\n      update_setup(generate_fen())\r\n  \r\n      return true\r\n    }\r\n  \r\n    function remove(square) {\r\n      var piece = get(square)\r\n      board[SQUARES[square]] = null\r\n      if (piece && piece.type === KING) {\r\n        kings[piece.color] = EMPTY\r\n      }\r\n  \r\n      update_setup(generate_fen())\r\n  \r\n      return piece\r\n    }\r\n  \r\n    function build_move(board, from, to, flags, promotion) {\r\n      var move = {\r\n        color: turn,\r\n        from: from,\r\n        to: to,\r\n        flags: flags,\r\n        piece: board[from].type\r\n      }\r\n  \r\n      if (promotion) {\r\n        move.flags |= BITS.PROMOTION\r\n        move.promotion = promotion\r\n      }\r\n  \r\n      if (board[to]) {\r\n        move.captured = board[to].type\r\n      } else if (flags & BITS.EP_CAPTURE) {\r\n        move.captured = PAWN\r\n      }\r\n      return move\r\n    }\r\n  \r\n    function generate_moves(options) {\r\n      function add_move(board, moves, from, to, flags) {\r\n        /* if pawn promotion */\r\n        if (\r\n          board[from].type === PAWN &&\r\n          (rank(to) === RANK_8 || rank(to) === RANK_1)\r\n        ) {\r\n          var pieces = [QUEEN, ROOK, BISHOP, KNIGHT]\r\n          for (var i = 0, len = pieces.length; i < len; i++) {\r\n            moves.push(build_move(board, from, to, flags, pieces[i]))\r\n          }\r\n        } else {\r\n          moves.push(build_move(board, from, to, flags))\r\n        }\r\n      }\r\n  \r\n      var moves = []\r\n      var us = turn\r\n      var them = swap_color(us)\r\n      var second_rank = { b: RANK_7, w: RANK_2 }\r\n  \r\n      var first_sq = SQUARES.a8\r\n      var last_sq = SQUARES.h1\r\n      var single_square = false\r\n  \r\n      /* do we want legal moves? */\r\n      var legal =\r\n        typeof options !== 'undefined' && 'legal' in options\r\n          ? options.legal\r\n          : true\r\n  \r\n      /* are we generating moves for a single square? */\r\n      if (typeof options !== 'undefined' && 'square' in options) {\r\n        if (options.square in SQUARES) {\r\n          first_sq = last_sq = SQUARES[options.square]\r\n          single_square = true\r\n        } else {\r\n          /* invalid square */\r\n          return []\r\n        }\r\n      }\r\n  \r\n      for (var i = first_sq; i <= last_sq; i++) {\r\n        /* did we run off the end of the board */\r\n        if (i & 0x88) {\r\n          i += 7\r\n          continue\r\n        }\r\n  \r\n        var piece = board[i]\r\n        if (piece == null || piece.color !== us) {\r\n          continue\r\n        }\r\n  \r\n        if (piece.type === PAWN) {\r\n          /* single square, non-capturing */\r\n          var square = i + PAWN_OFFSETS[us][0]\r\n          if (board[square] == null) {\r\n            add_move(board, moves, i, square, BITS.NORMAL)\r\n  \r\n            /* double square */\r\n            var square = i + PAWN_OFFSETS[us][1]\r\n            if (second_rank[us] === rank(i) && board[square] == null) {\r\n              add_move(board, moves, i, square, BITS.BIG_PAWN)\r\n            }\r\n          }\r\n  \r\n          /* pawn captures */\r\n          for (j = 2; j < 4; j++) {\r\n            var square = i + PAWN_OFFSETS[us][j]\r\n            if (square & 0x88) continue\r\n  \r\n            if (board[square] != null && board[square].color === them) {\r\n              add_move(board, moves, i, square, BITS.CAPTURE)\r\n            } else if (square === ep_square) {\r\n              add_move(board, moves, i, ep_square, BITS.EP_CAPTURE)\r\n            }\r\n          }\r\n        } else {\r\n          for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\r\n            var offset = PIECE_OFFSETS[piece.type][j]\r\n            var square = i\r\n  \r\n            while (true) {\r\n              square += offset\r\n              if (square & 0x88) break\r\n  \r\n              if (board[square] == null) {\r\n                add_move(board, moves, i, square, BITS.NORMAL)\r\n              } else {\r\n                if (board[square].color === us) break\r\n                add_move(board, moves, i, square, BITS.CAPTURE)\r\n                break\r\n              }\r\n  \r\n              /* break, if knight or king */\r\n              if (piece.type === 'n' || piece.type === 'k') break\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      /* check for castling if: a) we're generating all moves, or b) we're doing\r\n       * single square move generation on the king's square\r\n       */\r\n      if (!single_square || last_sq === kings[us]) {\r\n        /* king-side castling */\r\n        if (castling[us] & BITS.KSIDE_CASTLE) {\r\n          var castling_from = kings[us]\r\n          var castling_to = castling_from + 2\r\n  \r\n          if (\r\n            board[castling_from + 1] == null &&\r\n            board[castling_to] == null &&\r\n            !attacked(them, kings[us]) &&\r\n            !attacked(them, castling_from + 1) &&\r\n            !attacked(them, castling_to)\r\n          ) {\r\n            add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE)\r\n          }\r\n        }\r\n  \r\n        /* queen-side castling */\r\n        if (castling[us] & BITS.QSIDE_CASTLE) {\r\n          var castling_from = kings[us]\r\n          var castling_to = castling_from - 2\r\n  \r\n          if (\r\n            board[castling_from - 1] == null &&\r\n            board[castling_from - 2] == null &&\r\n            board[castling_from - 3] == null &&\r\n            !attacked(them, kings[us]) &&\r\n            !attacked(them, castling_from - 1) &&\r\n            !attacked(them, castling_to)\r\n          ) {\r\n            add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE)\r\n          }\r\n        }\r\n      }\r\n  \r\n      /* return all pseudo-legal moves (this includes moves that allow the king\r\n       * to be captured)\r\n       */\r\n      if (!legal) {\r\n        return moves\r\n      }\r\n  \r\n      /* filter out illegal moves */\r\n      var legal_moves = []\r\n      for (var i = 0, len = moves.length; i < len; i++) {\r\n        make_move(moves[i])\r\n        if (!king_attacked(us)) {\r\n          legal_moves.push(moves[i])\r\n        }\r\n        undo_move()\r\n      }\r\n  \r\n      return legal_moves\r\n    }\r\n  \r\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\r\n     * (SAN)\r\n     *\r\n     * @param {boolean} sloppy Use the sloppy SAN generator to work around over\r\n     * disambiguation bugs in Fritz and Chessbase.  See below:\r\n     *\r\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\r\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\r\n     * 4. ... Ne7 is technically the valid SAN\r\n     */\r\n    function move_to_san(move, sloppy) {\r\n      var output = ''\r\n  \r\n      if (move.flags & BITS.KSIDE_CASTLE) {\r\n        output = 'O-O'\r\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n        output = 'O-O-O'\r\n      } else {\r\n        var disambiguator = get_disambiguator(move, sloppy)\r\n  \r\n        if (move.piece !== PAWN) {\r\n          output += move.piece.toUpperCase() + disambiguator\r\n        }\r\n  \r\n        if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\r\n          if (move.piece === PAWN) {\r\n            output += algebraic(move.from)[0]\r\n          }\r\n          output += 'x'\r\n        }\r\n  \r\n        output += algebraic(move.to)\r\n  \r\n        if (move.flags & BITS.PROMOTION) {\r\n          output += '=' + move.promotion.toUpperCase()\r\n        }\r\n      }\r\n  \r\n      make_move(move)\r\n      if (in_check()) {\r\n        if (in_checkmate()) {\r\n          output += '#'\r\n        } else {\r\n          output += '+'\r\n        }\r\n      }\r\n      undo_move()\r\n  \r\n      return output\r\n    }\r\n  \r\n    // parses all of the decorators out of a SAN string\r\n    function stripped_san(move) {\r\n      return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\r\n    }\r\n  \r\n    function attacked(color, square) {\r\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\r\n        /* did we run off the end of the board */\r\n        if (i & 0x88) {\r\n          i += 7\r\n          continue\r\n        }\r\n  \r\n        /* if empty square or wrong color */\r\n        if (board[i] == null || board[i].color !== color) continue\r\n  \r\n        var piece = board[i]\r\n        var difference = i - square\r\n        var index = difference + 119\r\n  \r\n        if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {\r\n          if (piece.type === PAWN) {\r\n            if (difference > 0) {\r\n              if (piece.color === WHITE) return true\r\n            } else {\r\n              if (piece.color === BLACK) return true\r\n            }\r\n            continue\r\n          }\r\n  \r\n          /* if the piece is a knight or a king */\r\n          if (piece.type === 'n' || piece.type === 'k') return true\r\n  \r\n          var offset = RAYS[index]\r\n          var j = i + offset\r\n  \r\n          var blocked = false\r\n          while (j !== square) {\r\n            if (board[j] != null) {\r\n              blocked = true\r\n              break\r\n            }\r\n            j += offset\r\n          }\r\n  \r\n          if (!blocked) return true\r\n        }\r\n      }\r\n  \r\n      return false\r\n    }\r\n  \r\n    function king_attacked(color) {\r\n      return attacked(swap_color(color), kings[color])\r\n    }\r\n  \r\n    function in_check() {\r\n      return king_attacked(turn)\r\n    }\r\n  \r\n    function in_checkmate() {\r\n      return in_check() && generate_moves().length === 0\r\n    }\r\n  \r\n    function in_stalemate() {\r\n      return !in_check() && generate_moves().length === 0\r\n    }\r\n  \r\n    function insufficient_material() {\r\n      var pieces = {}\r\n      var bishops = []\r\n      var num_pieces = 0\r\n      var sq_color = 0\r\n  \r\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\r\n        sq_color = (sq_color + 1) % 2\r\n        if (i & 0x88) {\r\n          i += 7\r\n          continue\r\n        }\r\n  \r\n        var piece = board[i]\r\n        if (piece) {\r\n          pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\r\n          if (piece.type === BISHOP) {\r\n            bishops.push(sq_color)\r\n          }\r\n          num_pieces++\r\n        }\r\n      }\r\n  \r\n      /* k vs. k */\r\n      if (num_pieces === 2) {\r\n        return true\r\n      } else if (\r\n        /* k vs. kn .... or .... k vs. kb */\r\n        num_pieces === 3 &&\r\n        (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\r\n      ) {\r\n        return true\r\n      } else if (num_pieces === pieces[BISHOP] + 2) {\r\n        /* kb vs. kb where any number of bishops are all on the same color */\r\n        var sum = 0\r\n        var len = bishops.length\r\n        for (var i = 0; i < len; i++) {\r\n          sum += bishops[i]\r\n        }\r\n        if (sum === 0 || sum === len) {\r\n          return true\r\n        }\r\n      }\r\n  \r\n      return false\r\n    }\r\n  \r\n    function in_threefold_repetition() {\r\n      /* TODO: while this function is fine for casual use, a better\r\n       * implementation would use a Zobrist key (instead of FEN). the\r\n       * Zobrist key would be maintained in the make_move/undo_move functions,\r\n       * avoiding the costly that we do below.\r\n       */\r\n      var moves = []\r\n      var positions = {}\r\n      var repetition = false\r\n  \r\n      while (true) {\r\n        var move = undo_move()\r\n        if (!move) break\r\n        moves.push(move)\r\n      }\r\n  \r\n      while (true) {\r\n        /* remove the last two fields in the FEN string, they're not needed\r\n         * when checking for draw by rep */\r\n        var fen = generate_fen()\r\n          .split(' ')\r\n          .slice(0, 4)\r\n          .join(' ')\r\n  \r\n        /* has the position occurred three or move times */\r\n        positions[fen] = fen in positions ? positions[fen] + 1 : 1\r\n        if (positions[fen] >= 3) {\r\n          repetition = true\r\n        }\r\n  \r\n        if (!moves.length) {\r\n          break\r\n        }\r\n        make_move(moves.pop())\r\n      }\r\n  \r\n      return repetition\r\n    }\r\n  \r\n    function push(move) {\r\n      history.push({\r\n        move: move,\r\n        kings: { b: kings.b, w: kings.w },\r\n        turn: turn,\r\n        castling: { b: castling.b, w: castling.w },\r\n        ep_square: ep_square,\r\n        half_moves: half_moves,\r\n        move_number: move_number\r\n      })\r\n    }\r\n  \r\n    function make_move(move) {\r\n      var us = turn\r\n      var them = swap_color(us)\r\n      push(move)\r\n  \r\n      board[move.to] = board[move.from]\r\n      board[move.from] = null\r\n  \r\n      /* if ep capture, remove the captured pawn */\r\n      if (move.flags & BITS.EP_CAPTURE) {\r\n        if (turn === BLACK) {\r\n          board[move.to - 16] = null\r\n        } else {\r\n          board[move.to + 16] = null\r\n        }\r\n      }\r\n  \r\n      /* if pawn promotion, replace with new piece */\r\n      if (move.flags & BITS.PROMOTION) {\r\n        board[move.to] = { type: move.promotion, color: us }\r\n      }\r\n  \r\n      /* if we moved the king */\r\n      if (board[move.to].type === KING) {\r\n        kings[board[move.to].color] = move.to\r\n  \r\n        /* if we castled, move the rook next to the king */\r\n        if (move.flags & BITS.KSIDE_CASTLE) {\r\n          var castling_to = move.to - 1\r\n          var castling_from = move.to + 1\r\n          board[castling_to] = board[castling_from]\r\n          board[castling_from] = null\r\n        } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n          var castling_to = move.to + 1\r\n          var castling_from = move.to - 2\r\n          board[castling_to] = board[castling_from]\r\n          board[castling_from] = null\r\n        }\r\n  \r\n        /* turn off castling */\r\n        castling[us] = ''\r\n      }\r\n  \r\n      /* turn off castling if we move a rook */\r\n      if (castling[us]) {\r\n        for (var i = 0, len = ROOKS[us].length; i < len; i++) {\r\n          if (\r\n            move.from === ROOKS[us][i].square &&\r\n            castling[us] & ROOKS[us][i].flag\r\n          ) {\r\n            castling[us] ^= ROOKS[us][i].flag\r\n            break\r\n          }\r\n        }\r\n      }\r\n  \r\n      /* turn off castling if we capture a rook */\r\n      if (castling[them]) {\r\n        for (var i = 0, len = ROOKS[them].length; i < len; i++) {\r\n          if (\r\n            move.to === ROOKS[them][i].square &&\r\n            castling[them] & ROOKS[them][i].flag\r\n          ) {\r\n            castling[them] ^= ROOKS[them][i].flag\r\n            break\r\n          }\r\n        }\r\n      }\r\n  \r\n      /* if big pawn move, update the en passant square */\r\n      if (move.flags & BITS.BIG_PAWN) {\r\n        if (turn === 'b') {\r\n          ep_square = move.to - 16\r\n        } else {\r\n          ep_square = move.to + 16\r\n        }\r\n      } else {\r\n        ep_square = EMPTY\r\n      }\r\n  \r\n      /* reset the 50 move counter if a pawn is moved or a piece is captured */\r\n      if (move.piece === PAWN) {\r\n        half_moves = 0\r\n      } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\r\n        half_moves = 0\r\n      } else {\r\n        half_moves++\r\n      }\r\n  \r\n      if (turn === BLACK) {\r\n        move_number++\r\n      }\r\n      turn = swap_color(turn)\r\n    }\r\n  \r\n    function undo_move() {\r\n      var old = history.pop()\r\n      if (old == null) {\r\n        return null\r\n      }\r\n  \r\n      var move = old.move\r\n      kings = old.kings\r\n      turn = old.turn\r\n      castling = old.castling\r\n      ep_square = old.ep_square\r\n      half_moves = old.half_moves\r\n      move_number = old.move_number\r\n  \r\n      var us = turn\r\n      var them = swap_color(turn)\r\n  \r\n      board[move.from] = board[move.to]\r\n      board[move.from].type = move.piece // to undo any promotions\r\n      board[move.to] = null\r\n  \r\n      if (move.flags & BITS.CAPTURE) {\r\n        board[move.to] = { type: move.captured, color: them }\r\n      } else if (move.flags & BITS.EP_CAPTURE) {\r\n        var index\r\n        if (us === BLACK) {\r\n          index = move.to - 16\r\n        } else {\r\n          index = move.to + 16\r\n        }\r\n        board[index] = { type: PAWN, color: them }\r\n      }\r\n  \r\n      if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\r\n        var castling_to, castling_from\r\n        if (move.flags & BITS.KSIDE_CASTLE) {\r\n          castling_to = move.to + 1\r\n          castling_from = move.to - 1\r\n        } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n          castling_to = move.to - 2\r\n          castling_from = move.to + 1\r\n        }\r\n  \r\n        board[castling_to] = board[castling_from]\r\n        board[castling_from] = null\r\n      }\r\n  \r\n      return move\r\n    }\r\n  \r\n    /* this function is used to uniquely identify ambiguous moves */\r\n    function get_disambiguator(move, sloppy) {\r\n      var moves = generate_moves({ legal: !sloppy })\r\n  \r\n      var from = move.from\r\n      var to = move.to\r\n      var piece = move.piece\r\n  \r\n      var ambiguities = 0\r\n      var same_rank = 0\r\n      var same_file = 0\r\n  \r\n      for (var i = 0, len = moves.length; i < len; i++) {\r\n        var ambig_from = moves[i].from\r\n        var ambig_to = moves[i].to\r\n        var ambig_piece = moves[i].piece\r\n  \r\n        /* if a move of the same piece type ends on the same to square, we'll\r\n         * need to add a disambiguator to the algebraic notation\r\n         */\r\n        if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\r\n          ambiguities++\r\n  \r\n          if (rank(from) === rank(ambig_from)) {\r\n            same_rank++\r\n          }\r\n  \r\n          if (file(from) === file(ambig_from)) {\r\n            same_file++\r\n          }\r\n        }\r\n      }\r\n  \r\n      if (ambiguities > 0) {\r\n        /* if there exists a similar moving piece on the same rank and file as\r\n         * the move in question, use the square as the disambiguator\r\n         */\r\n        if (same_rank > 0 && same_file > 0) {\r\n          return algebraic(from)\r\n        } else if (same_file > 0) {\r\n          /* if the moving piece rests on the same file, use the rank symbol as the\r\n           * disambiguator\r\n           */\r\n          return algebraic(from).charAt(1)\r\n        } else {\r\n          /* else use the file symbol */\r\n          return algebraic(from).charAt(0)\r\n        }\r\n      }\r\n  \r\n      return ''\r\n    }\r\n  \r\n    function ascii() {\r\n      var s = '   +------------------------+\\n'\r\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\r\n        /* display the rank */\r\n        if (file(i) === 0) {\r\n          s += ' ' + '87654321'[rank(i)] + ' |'\r\n        }\r\n  \r\n        /* empty piece */\r\n        if (board[i] == null) {\r\n          s += ' . '\r\n        } else {\r\n          var piece = board[i].type\r\n          var color = board[i].color\r\n          var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\r\n          s += ' ' + symbol + ' '\r\n        }\r\n  \r\n        if ((i + 1) & 0x88) {\r\n          s += '|\\n'\r\n          i += 8\r\n        }\r\n      }\r\n      s += '   +------------------------+\\n'\r\n      s += '     a  b  c  d  e  f  g  h\\n'\r\n  \r\n      return s\r\n    }\r\n  \r\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\r\n    function move_from_san(move, sloppy) {\r\n      // strip off any move decorations: e.g Nf3+?!\r\n      var clean_move = stripped_san(move)\r\n  \r\n      // if we're using the sloppy parser run a regex to grab piece, to, and from\r\n      // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\r\n      if (sloppy) {\r\n        var matches = clean_move.match(\r\n          /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\r\n        )\r\n        if (matches) {\r\n          var piece = matches[1]\r\n          var from = matches[2]\r\n          var to = matches[3]\r\n          var promotion = matches[4]\r\n        }\r\n      }\r\n  \r\n      var moves = generate_moves()\r\n      for (var i = 0, len = moves.length; i < len; i++) {\r\n        // try the strict parser first, then the sloppy parser if requested\r\n        // by the user\r\n        if (\r\n          clean_move === stripped_san(move_to_san(moves[i])) ||\r\n          (sloppy && clean_move === stripped_san(move_to_san(moves[i], true)))\r\n        ) {\r\n          return moves[i]\r\n        } else {\r\n          if (\r\n            matches &&\r\n            (!piece || piece.toLowerCase() == moves[i].piece) &&\r\n            SQUARES[from] == moves[i].from &&\r\n            SQUARES[to] == moves[i].to &&\r\n            (!promotion || promotion.toLowerCase() == moves[i].promotion)\r\n          ) {\r\n            return moves[i]\r\n          }\r\n        }\r\n      }\r\n  \r\n      return null\r\n    }\r\n  \r\n    /*****************************************************************************\r\n     * UTILITY FUNCTIONS\r\n     ****************************************************************************/\r\n    function rank(i) {\r\n      return i >> 4\r\n    }\r\n  \r\n    function file(i) {\r\n      return i & 15\r\n    }\r\n  \r\n    function algebraic(i) {\r\n      var f = file(i),\r\n        r = rank(i)\r\n      return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1)\r\n    }\r\n  \r\n    function swap_color(c) {\r\n      return c === WHITE ? BLACK : WHITE\r\n    }\r\n  \r\n    function is_digit(c) {\r\n      return '0123456789'.indexOf(c) !== -1\r\n    }\r\n  \r\n    /* pretty = external move object */\r\n    function make_pretty(ugly_move) {\r\n      var move = clone(ugly_move)\r\n      move.san = move_to_san(move, false)\r\n      move.to = algebraic(move.to)\r\n      move.from = algebraic(move.from)\r\n  \r\n      var flags = ''\r\n  \r\n      for (var flag in BITS) {\r\n        if (BITS[flag] & move.flags) {\r\n          flags += FLAGS[flag]\r\n        }\r\n      }\r\n      move.flags = flags\r\n  \r\n      return move\r\n    }\r\n  \r\n    function clone(obj) {\r\n      var dupe = obj instanceof Array ? [] : {}\r\n  \r\n      for (var property in obj) {\r\n        if (typeof property === 'object') {\r\n          dupe[property] = clone(obj[property])\r\n        } else {\r\n          dupe[property] = obj[property]\r\n        }\r\n      }\r\n  \r\n      return dupe\r\n    }\r\n  \r\n    function trim(str) {\r\n      return str.replace(/^\\s+|\\s+$/g, '')\r\n    }\r\n  \r\n    /*****************************************************************************\r\n     * DEBUGGING UTILITIES\r\n     ****************************************************************************/\r\n    function perft(depth) {\r\n      var moves = generate_moves({ legal: false })\r\n      var nodes = 0\r\n      var color = turn\r\n  \r\n      for (var i = 0, len = moves.length; i < len; i++) {\r\n        make_move(moves[i])\r\n        if (!king_attacked(color)) {\r\n          if (depth - 1 > 0) {\r\n            var child_nodes = perft(depth - 1)\r\n            nodes += child_nodes\r\n          } else {\r\n            nodes++\r\n          }\r\n        }\r\n        undo_move()\r\n      }\r\n  \r\n      return nodes\r\n    }\r\n  \r\n    return {\r\n      /***************************************************************************\r\n       * PUBLIC CONSTANTS (is there a better way to do this?)\r\n       **************************************************************************/\r\n      WHITE: WHITE,\r\n      BLACK: BLACK,\r\n      PAWN: PAWN,\r\n      KNIGHT: KNIGHT,\r\n      BISHOP: BISHOP,\r\n      ROOK: ROOK,\r\n      QUEEN: QUEEN,\r\n      KING: KING,\r\n      SQUARES: (function() {\r\n        /* from the ECMA-262 spec (section 12.6.4):\r\n         * \"The mechanics of enumerating the properties ... is\r\n         * implementation dependent\"\r\n         * so: for (var sq in SQUARES) { keys.push(sq); } might not be\r\n         * ordered correctly\r\n         */\r\n        var keys = []\r\n        for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\r\n          if (i & 0x88) {\r\n            i += 7\r\n            continue\r\n          }\r\n          keys.push(algebraic(i))\r\n        }\r\n        return keys\r\n      })(),\r\n      FLAGS: FLAGS,\r\n  \r\n      /***************************************************************************\r\n       * PUBLIC API\r\n       **************************************************************************/\r\n      load: function(fen) {\r\n        return load(fen)\r\n      },\r\n  \r\n      reset: function() {\r\n        return reset()\r\n      },\r\n  \r\n      moves: function(options) {\r\n        /* The internal representation of a chess move is in 0x88 format, and\r\n         * not meant to be human-readable.  The code below converts the 0x88\r\n         * square coordinates to algebraic coordinates.  It also prunes an\r\n         * unnecessary move keys resulting from a verbose call.\r\n         */\r\n  \r\n        var ugly_moves = generate_moves(options)\r\n        var moves = []\r\n  \r\n        for (var i = 0, len = ugly_moves.length; i < len; i++) {\r\n          /* does the user want a full move object (most likely not), or just\r\n           * SAN\r\n           */\r\n          if (\r\n            typeof options !== 'undefined' &&\r\n            'verbose' in options &&\r\n            options.verbose\r\n          ) {\r\n            moves.push(make_pretty(ugly_moves[i]))\r\n          } else {\r\n            moves.push(move_to_san(ugly_moves[i], false))\r\n          }\r\n        }\r\n  \r\n        return moves\r\n      },\r\n\r\n      ugly_moves: function(options) {\r\n        var ugly_moves = generate_moves(options);\r\n        return ugly_moves;\r\n      },\r\n  \r\n      in_check: function() {\r\n        return in_check()\r\n      },\r\n  \r\n      in_checkmate: function() {\r\n        return in_checkmate()\r\n      },\r\n  \r\n      in_stalemate: function() {\r\n        return in_stalemate()\r\n      },\r\n  \r\n      in_draw: function() {\r\n        return (\r\n          half_moves >= 100 ||\r\n          in_stalemate() ||\r\n          insufficient_material() ||\r\n          in_threefold_repetition()\r\n        )\r\n      },\r\n  \r\n      insufficient_material: function() {\r\n        return insufficient_material()\r\n      },\r\n  \r\n      in_threefold_repetition: function() {\r\n        return in_threefold_repetition()\r\n      },\r\n  \r\n      game_over: function() {\r\n        return (\r\n          half_moves >= 100 ||\r\n          in_checkmate() ||\r\n          in_stalemate() ||\r\n          insufficient_material() ||\r\n          in_threefold_repetition()\r\n        )\r\n      },\r\n  \r\n      validate_fen: function(fen) {\r\n        return validate_fen(fen)\r\n      },\r\n  \r\n      fen: function() {\r\n        return generate_fen()\r\n      },\r\n  \r\n      board: function() {\r\n        var output = [],\r\n          row = []\r\n  \r\n        for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\r\n          if (board[i] == null) {\r\n            row.push(null)\r\n          } else {\r\n            row.push({ type: board[i].type, color: board[i].color })\r\n          }\r\n          if ((i + 1) & 0x88) {\r\n            output.push(row)\r\n            row = []\r\n            i += 8\r\n          }\r\n        }\r\n  \r\n        return output\r\n      },\r\n  \r\n      pgn: function(options) {\r\n        /* using the specification from http://www.chessclub.com/help/PGN-spec\r\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\r\n         */\r\n        var newline =\r\n          typeof options === 'object' && typeof options.newline_char === 'string'\r\n            ? options.newline_char\r\n            : '\\n'\r\n        var max_width =\r\n          typeof options === 'object' && typeof options.max_width === 'number'\r\n            ? options.max_width\r\n            : 0\r\n        var result = []\r\n        var header_exists = false\r\n  \r\n        /* add the PGN header headerrmation */\r\n        for (var i in header) {\r\n          /* TODO: order of enumerated properties in header object is not\r\n           * guaranteed, see ECMA-262 spec (section 12.6.4)\r\n           */\r\n          result.push('[' + i + ' \"' + header[i] + '\"]' + newline)\r\n          header_exists = true\r\n        }\r\n  \r\n        if (header_exists && history.length) {\r\n          result.push(newline)\r\n        }\r\n  \r\n        var append_comment = function(move_string) {\r\n          var comment = comments[generate_fen()]\r\n          if (typeof comment !== 'undefined') {\r\n            var delimiter = move_string.length > 0 ? ' ' : '';\r\n            move_string = `${move_string}${delimiter}{${comment}}`\r\n          }\r\n          return move_string\r\n        }\r\n  \r\n        /* pop all of history onto reversed_history */\r\n        var reversed_history = []\r\n        while (history.length > 0) {\r\n          reversed_history.push(undo_move())\r\n        }\r\n  \r\n        var moves = []\r\n        var move_string = ''\r\n  \r\n        /* special case of a commented starting position with no moves */\r\n        if (reversed_history.length === 0) {\r\n          moves.push(append_comment(''))\r\n        }\r\n  \r\n        /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\r\n        while (reversed_history.length > 0) {\r\n          move_string = append_comment(move_string)\r\n          var move = reversed_history.pop()\r\n  \r\n          /* if the position started with black to move, start PGN with 1. ... */\r\n          if (!history.length && move.color === 'b') {\r\n            move_string = move_number + '. ...'\r\n          } else if (move.color === 'w') {\r\n            /* store the previous generated move_string if we have one */\r\n            if (move_string.length) {\r\n              moves.push(move_string)\r\n            }\r\n            move_string = move_number + '.'\r\n          }\r\n  \r\n          move_string = move_string + ' ' + move_to_san(move, false)\r\n          make_move(move)\r\n        }\r\n  \r\n        /* are there any other leftover moves? */\r\n        if (move_string.length) {\r\n          moves.push(append_comment(move_string))\r\n        }\r\n  \r\n        /* is there a result? */\r\n        if (typeof header.Result !== 'undefined') {\r\n          moves.push(header.Result)\r\n        }\r\n  \r\n        /* history should be back to what it was before we started generating PGN,\r\n         * so join together moves\r\n         */\r\n        if (max_width === 0) {\r\n          return result.join('') + moves.join(' ')\r\n        }\r\n  \r\n        var strip = function() {\r\n          if (result.length > 0 && result[result.length - 1] === ' ') {\r\n            result.pop();\r\n            return true;\r\n          }\r\n          return false;\r\n        };\r\n  \r\n        /* NB: this does not preserve comment whitespace. */\r\n        var wrap_comment = function(width, move) {\r\n          for (var token of move.split(' ')) {\r\n            if (!token) {\r\n              continue;\r\n            }\r\n            if (width + token.length > max_width) {\r\n              while (strip()) {\r\n                width--;\r\n              }\r\n              result.push(newline);\r\n              width = 0;\r\n            }\r\n            result.push(token);\r\n            width += token.length;\r\n            result.push(' ');\r\n            width++;\r\n          }\r\n          if (strip()) {\r\n            width--;\r\n          }\r\n          return width;\r\n        };\r\n  \r\n        /* wrap the PGN output at max_width */\r\n        var current_width = 0\r\n        for (var i = 0; i < moves.length; i++) {\r\n          if (current_width + moves[i].length > max_width) {\r\n            if (moves[i].includes('{')) {\r\n              current_width = wrap_comment(current_width, moves[i]);\r\n              continue;\r\n            }\r\n          }\r\n          /* if the current move will push past max_width */\r\n          if (current_width + moves[i].length > max_width && i !== 0) {\r\n            /* don't end the line with whitespace */\r\n            if (result[result.length - 1] === ' ') {\r\n              result.pop()\r\n            }\r\n  \r\n            result.push(newline)\r\n            current_width = 0\r\n          } else if (i !== 0) {\r\n            result.push(' ')\r\n            current_width++\r\n          }\r\n          result.push(moves[i])\r\n          current_width += moves[i].length\r\n        }\r\n  \r\n        return result.join('')\r\n      },\r\n  \r\n      load_pgn: function(pgn, options) {\r\n        // allow the user to specify the sloppy move parser to work around over\r\n        // disambiguation bugs in Fritz and Chessbase\r\n        var sloppy =\r\n          typeof options !== 'undefined' && 'sloppy' in options\r\n            ? options.sloppy\r\n            : false\r\n  \r\n        function mask(str) {\r\n          return str.replace(/\\\\/g, '\\\\')\r\n        }\r\n  \r\n        function has_keys(object) {\r\n          for (var key in object) {\r\n            return true\r\n          }\r\n          return false\r\n        }\r\n  \r\n        function parse_pgn_header(header, options) {\r\n          var newline_char =\r\n            typeof options === 'object' &&\r\n            typeof options.newline_char === 'string'\r\n              ? options.newline_char\r\n              : '\\r?\\n'\r\n          var header_obj = {}\r\n          var headers = header.split(new RegExp(mask(newline_char)))\r\n          var key = ''\r\n          var value = ''\r\n  \r\n          for (var i = 0; i < headers.length; i++) {\r\n            key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1')\r\n            value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\ *\\]$/, '$1')\r\n            if (trim(key).length > 0) {\r\n              header_obj[key] = value\r\n            }\r\n          }\r\n  \r\n          return header_obj\r\n        }\r\n  \r\n        var newline_char =\r\n          typeof options === 'object' && typeof options.newline_char === 'string'\r\n            ? options.newline_char\r\n            : '\\r?\\n'\r\n  \r\n        // RegExp to split header. Takes advantage of the fact that header and movetext\r\n        // will always have a blank line between them (ie, two newline_char's).\r\n        // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\r\n        var header_regex = new RegExp(\r\n          '^(\\\\[((?:' +\r\n            mask(newline_char) +\r\n            ')|.)*\\\\])' +\r\n            '(?:' +\r\n            mask(newline_char) +\r\n            '){2}'\r\n        )\r\n  \r\n        // If no header given, begin with moves.\r\n        var header_string = header_regex.test(pgn)\r\n          ? header_regex.exec(pgn)[1]\r\n          : ''\r\n  \r\n        // Put the board in the starting position\r\n        reset()\r\n  \r\n        /* parse PGN header */\r\n        var headers = parse_pgn_header(header_string, options)\r\n        for (var key in headers) {\r\n          set_header([key, headers[key]])\r\n        }\r\n  \r\n        /* load the starting position indicated by [Setup '1'] and\r\n         * [FEN position] */\r\n        if (headers['SetUp'] === '1') {\r\n          if (!('FEN' in headers && load(headers['FEN'], true))) {\r\n            // second argument to load: don't clear the headers\r\n            return false\r\n          }\r\n        }\r\n  \r\n        /* NB: the regexes below that delete move numbers, recursive\r\n         * annotations, and numeric annotation glyphs may also match\r\n         * text in comments. To prevent this, we transform comments\r\n         * by hex-encoding them in place and decoding them again after\r\n         * the other tokens have been deleted.\r\n         *\r\n         * While the spec states that PGN files should be ASCII encoded,\r\n         * we use {en,de}codeURIComponent here to support arbitrary UTF8\r\n         * as a convenience for modern users */\r\n  \r\n        var to_hex = function(string) {\r\n          return Array\r\n            .from(string)\r\n            .map(function(c) {\r\n              /* encodeURI doesn't transform most ASCII characters,\r\n               * so we handle these ourselves */\r\n              return c.charCodeAt(0) < 128\r\n                ? c.charCodeAt(0).toString(16)\r\n                : encodeURIComponent(c).replace(/\\%/g, '').toLowerCase()\r\n            })\r\n            .join('')\r\n        }\r\n  \r\n        var from_hex = function(string) {\r\n          return string.length == 0\r\n            ? ''\r\n            : decodeURIComponent('%' + string.match(/.{1,2}/g).join('%'))\r\n        }\r\n  \r\n        var encode_comment = function(string) {\r\n          string = string.replace(new RegExp(mask(newline_char), 'g'), ' ')\r\n          return `{${to_hex(string.slice(1, string.length - 1))}}`\r\n        }\r\n  \r\n        var decode_comment = function(string) {\r\n          if (string.startsWith('{') && string.endsWith('}')) {\r\n            return from_hex(string.slice(1, string.length - 1))\r\n          }\r\n        }\r\n  \r\n        /* delete header to get the moves */\r\n        var ms = pgn\r\n          .replace(header_string, '')\r\n          .replace(\r\n            /* encode comments so they don't get deleted below */\r\n            new RegExp(`(\\{[^}]*\\})+?|;([^${mask(newline_char)}]*)`, 'g'),\r\n            function(match, bracket, semicolon) {\r\n              return bracket !== undefined\r\n                ? encode_comment(bracket)\r\n                : ' ' + encode_comment(`{${semicolon.slice(1)}}`)\r\n            }\r\n          )\r\n          .replace(new RegExp(mask(newline_char), 'g'), ' ')\r\n  \r\n        /* delete recursive annotation variations */\r\n        var rav_regex = /(\\([^\\(\\)]+\\))+?/g\r\n        while (rav_regex.test(ms)) {\r\n          ms = ms.replace(rav_regex, '')\r\n        }\r\n  \r\n        /* delete move numbers */\r\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\r\n  \r\n        /* delete ... indicating black to move */\r\n        ms = ms.replace(/\\.\\.\\./g, '')\r\n  \r\n        /* delete numeric annotation glyphs */\r\n        ms = ms.replace(/\\$\\d+/g, '')\r\n  \r\n        /* trim and get array of moves */\r\n        var moves = trim(ms).split(new RegExp(/\\s+/))\r\n  \r\n        /* delete empty entries */\r\n        moves = moves\r\n          .join(',')\r\n          .replace(/,,+/g, ',')\r\n          .split(',')\r\n        var move = ''\r\n  \r\n        for (var half_move = 0; half_move < moves.length - 1; half_move++) {\r\n          var comment = decode_comment(moves[half_move])\r\n          if (comment !== undefined) {\r\n            comments[generate_fen()] = comment\r\n            continue\r\n          }\r\n          move = move_from_san(moves[half_move], sloppy)\r\n  \r\n          /* move not possible! (don't clear the board to examine to show the\r\n           * latest valid position)\r\n           */\r\n          if (move == null) {\r\n            return false\r\n          } else {\r\n            make_move(move)\r\n          }\r\n        }\r\n  \r\n        comment = decode_comment(moves[moves.length - 1])\r\n        if (comment !== undefined) {\r\n          comments[generate_fen()] = comment\r\n          moves.pop()\r\n        }\r\n  \r\n        /* examine last move */\r\n        move = moves[moves.length - 1]\r\n        if (POSSIBLE_RESULTS.indexOf(move) > -1) {\r\n          if (has_keys(header) && typeof header.Result === 'undefined') {\r\n            set_header(['Result', move])\r\n          }\r\n        } else {\r\n          move = move_from_san(move, sloppy)\r\n          if (move == null) {\r\n            return false\r\n          } else {\r\n            make_move(move)\r\n          }\r\n        }\r\n        return true\r\n      },\r\n  \r\n      header: function() {\r\n        return set_header(arguments)\r\n      },\r\n  \r\n      ascii: function() {\r\n        return ascii()\r\n      },\r\n  \r\n      turn: function() {\r\n        return turn\r\n      },\r\n  \r\n      move: function(move, options) {\r\n        /* The move function can be called with in the following parameters:\r\n         *\r\n         * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\r\n         *\r\n         * .move({ from: 'h7', <- where the 'move' is a move object (additional\r\n         *         to :'h8',      fields are ignored)\r\n         *         promotion: 'q',\r\n         *      })\r\n         */\r\n  \r\n        // allow the user to specify the sloppy move parser to work around over\r\n        // disambiguation bugs in Fritz and Chessbase\r\n        var sloppy =\r\n          typeof options !== 'undefined' && 'sloppy' in options\r\n            ? options.sloppy\r\n            : false\r\n  \r\n        var move_obj = null\r\n  \r\n        if (typeof move === 'string') {\r\n          move_obj = move_from_san(move, sloppy)\r\n        } else if (typeof move === 'object') {\r\n          var moves = generate_moves()\r\n  \r\n          /* convert the pretty move object to an ugly move object */\r\n          for (var i = 0, len = moves.length; i < len; i++) {\r\n            if (\r\n              move.from === algebraic(moves[i].from) &&\r\n              move.to === algebraic(moves[i].to) &&\r\n              (!('promotion' in moves[i]) ||\r\n                move.promotion === moves[i].promotion)\r\n            ) {\r\n              move_obj = moves[i]\r\n              break\r\n            }\r\n          }\r\n        }\r\n  \r\n        /* failed to find move */\r\n        if (!move_obj) {\r\n          return null\r\n        }\r\n  \r\n        /* need to make a copy of move because we can't generate SAN after the\r\n         * move is made\r\n         */\r\n        var pretty_move = make_pretty(move_obj)\r\n  \r\n        make_move(move_obj)\r\n  \r\n        return pretty_move\r\n      },\r\n\r\n      ugly_move: function(move_obj, options) {\r\n        var pretty_move = make_pretty(move_obj);\r\n        make_move(move_obj);\r\n\r\n        return pretty_move;\r\n      },\r\n  \r\n      undo: function() {\r\n        var move = undo_move()\r\n        return move ? make_pretty(move) : null\r\n      },\r\n  \r\n      clear: function() {\r\n        return clear()\r\n      },\r\n  \r\n      put: function(piece, square) {\r\n        return put(piece, square)\r\n      },\r\n  \r\n      get: function(square) {\r\n        return get(square)\r\n      },\r\n  \r\n      remove: function(square) {\r\n        return remove(square)\r\n      },\r\n  \r\n      perft: function(depth) {\r\n        return perft(depth)\r\n      },\r\n  \r\n      square_color: function(square) {\r\n        if (square in SQUARES) {\r\n          var sq_0x88 = SQUARES[square]\r\n          return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark'\r\n        }\r\n  \r\n        return null\r\n      },\r\n  \r\n      history: function(options) {\r\n        var reversed_history = []\r\n        var move_history = []\r\n        var verbose =\r\n          typeof options !== 'undefined' &&\r\n          'verbose' in options &&\r\n          options.verbose\r\n  \r\n        while (history.length > 0) {\r\n          reversed_history.push(undo_move())\r\n        }\r\n  \r\n        while (reversed_history.length > 0) {\r\n          var move = reversed_history.pop()\r\n          if (verbose) {\r\n            move_history.push(make_pretty(move))\r\n          } else {\r\n            move_history.push(move_to_san(move))\r\n          }\r\n          make_move(move)\r\n        }\r\n  \r\n        return move_history\r\n      },\r\n  \r\n      get_comment: function() {\r\n        return comments[generate_fen()];\r\n      },\r\n  \r\n      set_comment: function(comment) {\r\n        comments[generate_fen()] = comment.replace('{', '[').replace('}', ']');\r\n      },\r\n  \r\n      delete_comment: function() {\r\n        var comment = comments[generate_fen()];\r\n        delete comments[generate_fen()];\r\n        return comment;\r\n      },\r\n  \r\n      get_comments: function() {\r\n        prune_comments();\r\n        return Object.keys(comments).map(function(fen) {\r\n          return {fen: fen, comment: comments[fen]};\r\n        });\r\n      },\r\n  \r\n      delete_comments: function() {\r\n        prune_comments();\r\n        return Object.keys(comments)\r\n          .map(function(fen) {\r\n            var comment = comments[fen];\r\n            delete comments[fen];\r\n            return {fen: fen, comment: comment};\r\n          });\r\n      }\r\n    }\r\n  }\r\n  \r\n  /* export Chess object if using node or any other CommonJS compatible\r\n   * environment */\r\n  if (typeof exports !== 'undefined') exports.Chess = Chess\r\n  /* export Chess object for any RequireJS compatible environment */\r\n  if (typeof define !== 'undefined')\r\n    define(function() {\r\n      return Chess\r\n    })"],"names":["Chess","fen","DEFAULT_POSITION","POSSIBLE_RESULTS","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","SHIFTS","p","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","BITS","SQUARES","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","ROOKS","square","flag","board","Array","kings","turn","castling","ep_square","half_moves","move_number","history","header","comments","clear","keep_headers","update_setup","generate_fen","prune_comments","reversed_history","current_comments","copy_comment","length","push","undo_move","make_move","pop","load","tokens","split","position","validate_fen","valid","i","piece","charAt","indexOf","parseInt","color","put","type","toLowerCase","algebraic","errors","error_number","error","isNaN","test","rows","sum_fields","previous_was_number","empty","toUpperCase","cflags","epflags","join","set_header","args","get","SYMBOLS","sq","build_move","from","to","flags","promotion","move","captured","generate_moves","options","add_move","moves","rank","pieces","len","us","them","swap_color","second_rank","first_sq","last_sq","single_square","legal","j","offset","castling_from","castling_to","attacked","legal_moves","king_attacked","move_to_san","sloppy","output","disambiguator","get_disambiguator","ambiguities","same_rank","same_file","ambig_from","ambig_to","in_checkmate","stripped_san","replace","difference","index","blocked","in_check","in_stalemate","insufficient_material","bishops","num_pieces","sq_color","sum","in_threefold_repetition","positions","repetition","slice","old","move_from_san","clean_move","matches","match","f","substring","c","make_pretty","ugly_move","clone","obj","dupe","property","san","trim","str","WHITE","BLACK","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","keys","reset","ugly_moves","verbose","in_draw","game_over","row","pgn","newline","newline_char","max_width","result","header_exists","append_comment","move_string","comment","delimiter","Result","strip","current_width","includes","wrap_comment","width","token","load_pgn","mask","header_regex","RegExp","header_string","exec","headers","parse_pgn_header","header_obj","key","value","encode_comment","string","map","charCodeAt","toString","encodeURIComponent","decode_comment","startsWith","endsWith","decodeURIComponent","ms","bracket","semicolon","undefined","rav_regex","half_move","has_keys","object","arguments","ascii","s","move_obj","pretty_move","undo","remove","perft","depth","nodes","square_color","sq_0x88","move_history","get_comment","set_comment","delete_comment","get_comments","Object","delete_comments","exports","define"],"version":3,"file":"chess.bef3132b.js.map"}